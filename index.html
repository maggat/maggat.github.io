<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
   <title>ArmaHeaven X195 — Earth + Orbits</title>
   <!-- Retro terminal font -->
   <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
     body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #000;
        font-family: Arial, sans-serif;
        color: #fff;
     }
     .overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 10;
     }
     h1 {
        font-size: 3em;
        margin: 0 0 20px 0;
        letter-spacing: 2px;
     }
     p {
        font-size: 1.2em;
        margin: 0 0 20px 0;
     }
     .links {
        margin-top: 20px;
     }
     .links a {
        display: inline-block;
        margin: 0 10px;
        padding: 10px 20px;
        border: 2px solid #fff;
        color: #fff;
        text-decoration: none;
        border-radius: 5px;
        transition: all 0.3s ease;
     }
     .links a:hover {
        background: #fff;
        color: #000;
     }
     /* Terminal style text: monospaced, glowing green, blinking caret */
     .terminal {
        font-family: 'VT323', SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        color: #00ff6a;
        text-shadow: 0 0 6px rgba(0,255,106,0.8), 0 0 18px rgba(0,255,106,0.5);
     }
     .terminal h1, .terminal p { color: inherit; text-shadow: inherit; }
     .caret {
        display: inline-block;
        margin-left: 6px;
        width: 0.6ch;
        color: #00ff6a;
        text-shadow: 0 0 10px rgba(0,255,106,0.9), 0 0 24px rgba(0,255,106,0.6);
        animation: blink 1s steps(1, end) infinite;
     }
     @keyframes blink {
        0%, 49% { opacity: 1; }
        50%, 100% { opacity: 0; }
     }
     /* Make the links fit the green terminal theme */
     .links a {
        border-color: #00ff6a;
        color: #00ff6a;
        text-shadow: 0 0 6px rgba(0,255,106,0.8);
     }
     .links a:hover {
        background: #00ff6a;
        color: #000;
        box-shadow: 0 0 12px rgba(0,255,106,0.8), 0 0 30px rgba(0,255,106,0.5);
     }
   /* Make the logo pop over a dark scene: use screen blend and a soft glow */
   .logo {
      mix-blend-mode: screen; /* brightens over dark backgrounds; keeps white transparent areas subtle */
      filter: drop-shadow(0 0 12px rgba(255,255,255,0.6));
   }
   /* Fixed logo in upper-left corner */
   .logo-fixed {
      position: fixed;
      top: 12px;
      left: 12px;
      width: 120px;
      height: auto;
      z-index: 30;
      pointer-events: auto;
      cursor: pointer;
      transition: transform 0.15s ease, filter 0.15s ease;
   }
   .logo-fixed:hover {
      transform: scale(1.04);
      filter: drop-shadow(0 0 16px rgba(255,255,255,0.85));
   }
   /* Bottom-right icon links */
   .corner-links {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 12;
      display: flex;
      gap: 12px;
      align-items: center;
   }
   .corner-links a {
      display: inline-flex;
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: rgba(255,255,255,0.06);
      backdrop-filter: blur(2px);
      justify-content: center;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.12);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
   }
   .corner-links a:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 14px rgba(51,179,255,0.85), 0 0 32px rgba(51,179,255,0.55);
      background: rgba(51,179,255,0.15);
      border-color: rgba(51,179,255,0.7);
    }
   .corner-links svg { width: 22px; height: 22px; }
   .corner-links .spotify { fill: #1ED760; }
   .corner-links .patreon { fill: #FF424D; }
   .corner-links a:hover .spotify, .corner-links a:hover .patreon { fill: #33b3ff; }

   .fullscreen-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      padding: 8px 14px;
      font-family: 'VT323', monospace;
      font-size: 16px;
      letter-spacing: 1px;
      color: #cfeeff;
      background: rgba(10, 18, 24, 0.75);
      border: 1px solid rgba(80, 200, 255, 0.6);
      border-radius: 8px;
      text-shadow: 0 0 8px rgba(51, 179, 255, 0.8);
      box-shadow: 0 0 14px rgba(51, 179, 255, 0.45);
      cursor: pointer;
      z-index: 32;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
   }

   .fullscreen-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 22px rgba(51, 179, 255, 0.75);
   }

   .fullscreen-toggle:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(16, 190, 255, 0.45), 0 0 22px rgba(51, 179, 255, 0.8);
   }

   /* Darkening overlay under text */
   .shade {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      z-index: 5; /* below overlay (10), above canvas */
      pointer-events: none;
   }
    /* Intro modal */
    .modal-backdrop {
         position: fixed;
         inset: 0;
         background: rgba(0,0,0,0.7);
         display: flex;
         align-items: center;
         justify-content: center;
         z-index: 40;
      }
      .modal-card {
         background: rgba(10,10,14,0.85);
         border: 1px solid rgba(51,179,255,0.4);
         border-radius: 12px;
         padding: 22px 26px;
         width: min(92vw, 560px);
         box-shadow: 0 0 26px rgba(51,179,255,0.5), 0 0 60px rgba(26,120,190,0.35);
         text-align: center;
         backdrop-filter: blur(6px);
      }
      .modal-card h2 {
         font-family: 'VT323', monospace;
         font-size: 40px;
         margin: 0 0 8px 0;
         color: #33b3ff;
         text-shadow: 0 0 10px rgba(51,179,255,0.9);
      }
      .modal-card p {
         font-family: 'VT323', monospace;
         font-size: 22px;
         color: #9fd9ff;
         margin: 0 0 18px 0;
      }
      .modal-actions button {
         font-family: 'VT323', monospace;
         font-size: 18px;
         padding: 10px 16px;
         color: #cfeeff;
         background: rgba(51,179,255,0.12);
         border: 1px solid rgba(51,179,255,0.6);
         border-radius: 8px;
         cursor: pointer;
         text-shadow: 0 0 10px rgba(51,179,255,0.8);
         box-shadow: 0 0 12px rgba(51,179,255,0.5);
      }
      .modal-actions button:hover {
         box-shadow: 0 0 18px rgba(51,179,255,0.9), 0 0 38px rgba(51,179,255,0.6);
         color: #e9f7ff;
         background: rgba(51,179,255,0.2);
      }
   /* Simple audio player widget */
   .audio-widget {
      position: fixed;
      left: 12px;
      bottom: 56px; /* sit above the HUD */
      z-index: 22;
      display: flex;
      gap: 10px;
      align-items: center;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 8px 10px;
      backdrop-filter: blur(3px);
   }
   .audio-widget button {
      font-family: 'VT323', monospace;
      font-size: 16px;
      padding: 6px 10px;
      color: #00ff6a;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(0,255,106,0.5);
      border-radius: 6px;
      text-shadow: 0 0 6px rgba(0,255,106,0.8);
      cursor: pointer;
   }
   .audio-widget button:hover { box-shadow: 0 0 14px rgba(51,179,255,0.85), 0 0 32px rgba(51,179,255,0.55); color: #66ccff; border-color: rgba(102,204,255,0.8); }
   .audio-widget a {
      color: #1ED760;
      text-decoration: none;
      font-family: 'VT323', monospace;
      font-size: 16px;
      border-bottom: 1px dashed rgba(30,215,96,0.6);
   }
   .audio-widget a:hover { color: #6ff0a3; }
       .hud {
            position: absolute;
            left: 12px;
            bottom: 12px;
            opacity: 0.7;
            font-size: 12px;
            z-index: 10;
       }
   /* Healthbar (offset to avoid overlapping the top-left logo) */
   .healthbar { position: fixed; top: 12px; left: 150px; width: 220px; height: 18px; border: 1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.35); backdrop-filter: blur(4px); z-index: 30; display: none; }
     .healthbar .fill { height: 100%; width: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); box-shadow: 0 0 12px rgba(46,204,113,0.7) inset; transition: width 120ms ease-out; }
     .healthbar.low .fill { background: linear-gradient(90deg, #ff6b6b, #e74c3c); box-shadow: 0 0 12px rgba(255,107,107,0.7) inset; }
     .healthbar .label { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; font-family: 'VT323', monospace; font-size: 14px; text-shadow: 0 0 6px rgba(0,0,0,0.6); }
   /* Damage flash overlay */
   #damageFlash { position: fixed; inset: 0; pointer-events: none; z-index: 40; background: rgba(255,30,20,0); mix-blend-mode: screen; }
   /* Overdrive bar (below healthbar) */
   .overdrivebar { position: fixed; top: 36px; left: 150px; width: 180px; height: 12px; border: 1px solid rgba(80,240,255,0.7); background: rgba(0,20,28,0.5); backdrop-filter: blur(3px); z-index: 30; display: none; }
   .overdrivebar .fill { height: 100%; width: 0%; background: linear-gradient(90deg, #33e6ff, #009db3); box-shadow: 0 0 10px rgba(0,200,220,0.8) inset; transition: width 100ms linear; }
   .overdrivebar .label { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #bdf6ff; font-family: 'VT323', monospace; font-size: 12px; text-shadow: 0 0 6px rgba(0,0,0,0.6); }
   /* Overheat bar (below overdrive) */
   .overheatbar { position: fixed; top: 54px; left: 150px; width: 180px; height: 12px; border: 1px solid rgba(255,140,40,0.7); background: rgba(20,8,0,0.5); backdrop-filter: blur(3px); z-index: 30; display: none; }
   .overheatbar .fill { height: 100%; width: 0%; background: linear-gradient(90deg, #ffaa33, #ff4422); box-shadow: 0 0 10px rgba(255,80,40,0.8) inset; transition: width 100ms linear; }
   .overheatbar.overheated .fill { background: linear-gradient(90deg, #ff4422, #cc1100); animation: overheat-pulse 0.5s ease-in-out infinite alternate; }
   .overheatbar .label { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #ffd6aa; font-family: 'VT323', monospace; font-size: 12px; text-shadow: 0 0 6px rgba(0,0,0,0.6); }
   @keyframes overheat-pulse { from { opacity: 0.7; } to { opacity: 1.0; } }
  /* Mobile controls overlay */
  .mobile-controls { position: fixed; inset: 0; z-index: 25; pointer-events: none; }
  .mobile-controls .pad {
     position: absolute; bottom: 16px; left: 16px;
     width: min(34vw, 180px); height: min(34vw, 180px);
     border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
     background: rgba(255,255,255,0.05);
     backdrop-filter: blur(4px);
     pointer-events: auto;
     touch-action: none;
  }
  .mobile-controls .stick {
     position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
     width: 40%; height: 40%; border-radius: 50%;
     background: radial-gradient(circle, rgba(51,179,255,0.9), rgba(51,179,255,0.3));
     border: 1px solid rgba(51,179,255,0.7);
  }
  .mobile-controls .fire {
     position: absolute; right: 16px; bottom: 16px;
     width: min(22vw, 120px); height: min(22vw, 120px);
     border-radius: 50%;
     background: radial-gradient(circle, rgba(255,80,80,0.9), rgba(255,80,80,0.25));
     border: 1px solid rgba(255,120,120,0.7);
     box-shadow: 0 0 18px rgba(255,80,80,0.7);
     pointer-events: auto;
     touch-action: manipulation;
   }
  .mobile-controls .fire:active { transform: scale(0.96); }
   /* Hide mobile controls when aria-hidden is true */
   .mobile-controls[aria-hidden="true"] { display: none; }

  /* Responsive tweaks */
  @media (max-width: 820px), (pointer: coarse) {
     .logo-fixed { width: 84px; }
     .corner-links { right: 8px; bottom: 8px; }
     .corner-links a { width: 36px; height: 36px; }
     .terminal h1 { font-size: 9.5vw; }
     .terminal p { font-size: 4.4vw; }
     .audio-widget { display: none; }
     .hud { font-size: 13px; }
  }
  /* Hidden YouTube holder for background audio */
  #yt-holder {
   position: fixed;
   width: 1px;
   height: 1px;
   left: -10000px;
   top: auto;
   opacity: 0;
   pointer-events: none;
   z-index: -1;
  }
  </style>
</head>
<body>
<div id="container"></div>
<div class="shade"></div>
<button id="fullscreenToggle" class="fullscreen-toggle" type="button" aria-pressed="false">FULLSCREEN</button>
<!-- HUD for score/health -->
<div class="hud"></div>
<!-- Healthbar -->
<div id="healthbar" class="healthbar" aria-hidden="true"><div class="fill"></div><div class="label">100</div></div>
<div id="damageFlash" aria-hidden="true"></div>
<!-- Overdrive bar -->
<div id="overdrive" class="overdrivebar" aria-hidden="true"><div class="fill"></div><div class="label">OVERDRIVE</div></div>
<!-- Overheat bar -->
<!-- <div id="overheat" class="overheatbar" aria-hidden="true"><div class="fill"></div><div class="label">HEAT</div></div> -->
<!-- Intro modal -->
<div id="readyModal" class="modal-backdrop">
   <div class="modal-card">
      <h2>Are you ready?</h2>
      <p>Headphones on. Neony engaged. Let’s go.</p>
      <div class="modal-actions">
         <button id="readyBtn">Enter</button>
      </div>
   </div>
  
</div>
<!-- Victory modal -->
<div id="winModal" class="modal-backdrop" style="display:none">
   <div class="modal-card">
      <h2>Mission Complete</h2>
      <p>SMASH INTO PIECES is actively working on a video game to be released in 2026.<br/>More news coming soon.</p>
      <div class="modal-actions">
         <button id="winOkBtn">OK</button>
      </div>
   </div>
</div>
<!-- Fixed logo in top-left -->
<img class="logo logo-fixed" src="./apoc-sip-symbol.png" alt="Apoc Logo">
<div class="overlay">
    <div class="terminal">
      <h1>ArmaHeaven X195</h1>
   <p>Are you prepared for what's coming? Can you see into the future?<span class="caret">▌</span></p>
    </div>
</div>
<!-- Mobile controls (shown on touch devices) -->
<div class="mobile-controls" aria-hidden="true">
   <div class="pad" id="joyLeft">
       <div class="stick" id="joyStick"></div>
   </div>
   <button class="fire" id="fireBtn" aria-label="Fire"></button>
</div>

<!-- Bottom-right icon links -->
<div class="corner-links">
  <a href="https://open.spotify.com/artist/2vhrwzjf9H3icunkVFi9tq?" target="_blank" aria-label="Spotify">
    <svg class="spotify" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img">
      <path d="M12 0C5.372 0 0 5.373 0 12c0 6.628 5.372 12 12 12s12-5.372 12-12C24 5.373 18.628 0 12 0zm5.484 17.28a.752.752 0 0 1-1.036.246c-2.839-1.736-6.42-2.13-10.62-1.172a.75.75 0 1 1-.33-1.462c4.56-1.032 8.5-.583 11.61 1.29.357.218.47.684.246 1.098zm1.375-3.08a.94.94 0 0 1-1.298.307c-3.25-1.99-8.206-2.57-12.056-1.418a.94.94 0 1 1-.536-1.806c4.32-1.28 9.77-.64 13.4 1.55a.94.94 0 0 1 .49 1.366zm.13-3.235a1.126 1.126 0 0 1-1.556.368c-3.72-2.27-9.39-2.48-12.753-1.382a1.125 1.125 0 0 1-.67-2.152c3.89-1.213 10.21-1.003 14.48 1.586.52.317.69 1 .5 1.58z"/>
    </svg>
  </a>
  <a href="https://www.patreon.com/smashheads" target="_blank" aria-label="Patreon">
    <svg class="patreon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img">
      <path d="M1.5 2h3v20h-3V2zm13 0A8.5 8.5 0 0 1 23 10.5c0 4.694-3.806 8.5-8.5 8.5H12V2h2.5z"/>
    </svg>
  </a>
</div>
<!-- YouTube IFrame API for background music -->
<script src="https://www.youtube.com/iframe_api"></script>
<!-- Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- GLTFLoader for ship model -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<!-- Postprocessing for glow/bloom (r128-compatible) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<!-- Lens flare for the Sun -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Lensflare.js"></script>
<!-- Subtle motion blur (Afterimage) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/AfterimageShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/AfterimagePass.js"></script>
<!-- Motion blur removed -->
<!-- Explosion pooling system -->
<script src="js/explosions.js"></script>
<!-- Gamepad support -->
<script src="js/gamepad.js"></script>
<script>
let scene, camera, renderer, stars;
let earth, ships = [], clock;
let cleanupQueue = [];
let composer, bloomPass, afterimagePass, vignettePass, distortionPass, beam, redLight;
let sunLight = null, sunCore = null, sunGlow = null;
let shipGLTF = null;
let trailTexture = null;
let cameraOrbit = null; // { radius, theta, speed, height }
let playerShip = null; // player's ship spawned in flight mode
let engineGlows = []; // sprites for engine flames
let playerTrail = null; // player's trail { len, geom, positions, colors, points }
let planets = []; // distant planets with enemies
// Speed lines effect state
let speedLines = { group: null, sprites: [], texture: null, active: false };
const curiosa = {
   p1: 'Per grew up deep in the forest, passionate about fly fishing in remote woodland lakes, testing his own handmade flies. A true forest dweller at heart.',
   p2: 'Adam is a big Blizzard fan who brings strategic thinking and gaming passion to the band\'s creative process. He is also a wheelie expert.',
   p3: 'Benjamin is the band\'s philosopher and gentle clown. He feels deeply, writes nostalgic and emotionally charged music, and carefully assembled each band member like puzzle pieces into this world.',
   p4: 'Apoc is a multi-instrumentalist and musical visionary who weaves together the band\'s diverse sounds, channeling raw emotion and technical mastery into every performance.'
};
// Smooth flight feel state
let shipSway = 0, shipSwayTarget = 0;           // lateral offset (meters)
let shipBank = 0, shipBankTarget = 0;           // roll around forward (radians)
let shipPitchLean = 0, shipPitchLeanTarget = 0; // slight nose tilt with accel (radians)
let playerVel = new THREE.Vector3();            // player velocity (world units/sec)
// Damage FX state
let damageFlashEl = null, damageFlashAlpha = 0;
let shakeTime = 0, shakeDuration = 0.25, shakeMagnitude = 0;
// Boost FX state (non-blur): FOV kick + vignette
let boostFx = 0, boostFxTarget = 0, wasBoosting = false;
let boostPulse = 0; // short pulse on boost engage for shock/distortion
// Mobile controls state
let mobile = {
   active: false,                // true on touch devices
   move: { x: 0, y: 0 },         // left stick normalized [-1,1]
   lookDelta: { x: 0, y: 0 },    // accumulated look deltas (pixels) since last frame
   firing: false,                // fire button held
   touching: false, id: null,    // joystick pointer tracking
   center: { x: 0, y: 0 }, radius: 80,
   stickEl: null, padEl: null, fireBtn: null,
   lookId: null, prevLook: { x: 0, y: 0 }
};
const Y_AXIS = new THREE.Vector3(0, 1, 0);
// Player-specific yaw offset (rotate a bit further to the left)
const PLAYER_YAW_LEFT = new THREE.Quaternion().setFromAxisAngle(Y_AXIS, -THREE.MathUtils.degToRad(0));
// Enemy ships need an additional left yaw to align their noses with motion
const ENEMY_YAW_LEFT = new THREE.Quaternion().setFromAxisAngle(Y_AXIS, THREE.MathUtils.degToRad(45));

// Secret flight mode
let flightMode = false;
let yaw = 0, pitch = 0;          // smoothed orientation
let yawTarget = 0, pitchTarget = 0; // target orientation (mouse input)
const maxPitch = Math.PI / 2 - 0.05;
const keys = { w:false, a:false, s:false, d:false, q:false, e:false, shift:false };
let bullets = [];
let explosions = [];
let enemyBullets = [];
let flashes = [];
let pickups = [];
let asteroids = [];
let pickupRespawns = [];
let lastTime = 0;
let fireCooldown = 0;
let score = 0;
let weaponHeat = 0; // 0-1, builds when firing
let weaponOverheated = false;
let overheatCooldownTimer = 0;
let bulletGeom, bulletMat;
let enemyBulletGeom, enemyBulletMat;
let playerHealth = 100;
let victoryShown = false;
let gameTime = 0;
// Enemy fire grace period: enemies won't shoot until after this timestamp (in seconds)
let enemyFireUnlockAt = 0;
// SFX buffers
let sfxCtx = null;
const sfx = { click: null, laser: null, explosion: null, boost: null, boostRev: null };
let lastBoostSfxTime = 0; // seconds, to debounce boost trigger sound
let lastBoostReleaseSfxTime = 0; // debounce for release whoosh
// Engine loop audio
let engine = { initialized:false, master:null, baseOsc:null, baseGain:null, overtoneOsc:null, overtoneGain:null };
let engineThrottle = 0, engineThrottleTarget = 0;
let canvas = null;
let mouseFiring = false; // hold-to-fire on desktop

// Model URL (place your file at this path or change the URL to match your asset)
const SHIP_MODEL_URL = './3d/ship.glb';

function setupFullscreenToggle(){
   const btn = document.getElementById('fullscreenToggle');
   if (!btn) return;

   const updateLabel = () => {
      const active = !!document.fullscreenElement || !!document.webkitFullscreenElement;
      btn.textContent = active ? 'EXIT FULLSCREEN' : 'FULLSCREEN';
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      btn.title = active ? 'Exit fullscreen (Esc)' : 'Enter fullscreen';
   };

   const request = () => {
      const elem = document.documentElement;
      const fn = elem.requestFullscreen || elem.webkitRequestFullscreen || elem.mozRequestFullScreen || elem.msRequestFullscreen;
      if (fn) {
         try {
            const result = fn.call(elem);
            if (result && typeof result.catch === 'function') {
               result.catch(() => {});
            }
         } catch(_){ }
      }
   };

   const exit = () => {
      const fn = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
      if (fn) {
         try {
            const result = fn.call(document);
            if (result && typeof result.catch === 'function') {
               result.catch(() => {});
            }
         } catch(_){ }
      }
   };

   btn.addEventListener('click', () => {
      const active = !!document.fullscreenElement || !!document.webkitFullscreenElement;
      if (active) {
         exit();
      } else {
         request();
      }
   });

   document.addEventListener('fullscreenchange', updateLabel);
   document.addEventListener('webkitfullscreenchange', updateLabel);
   updateLabel();
}

function setupMobileControls(){
   // Determine if we're on a touch/coarse device
   const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || window.matchMedia('(pointer: coarse)').matches;
   mobile.active = !!isTouch;
   const controls = document.querySelector('.mobile-controls');
   if (!controls) return;

   // Visibility helper
   const applyVisibility = () => {
      if (mobile.active) {
         controls.setAttribute('aria-hidden', 'false');
         controls.style.display = '';
      } else {
         controls.setAttribute('aria-hidden', 'true');
         controls.style.display = 'none';
      }
   };
   applyVisibility();

   // Cache elements
   mobile.padEl = document.getElementById('joyLeft');
   mobile.stickEl = document.getElementById('joyStick');
   mobile.fireBtn = document.getElementById('fireBtn');
   const canvasEl = (renderer && renderer.domElement) ? renderer.domElement : document.getElementById('container');

   // Helper to clamp stick and update mobile.move
   function updateStick(clientX, clientY){
      const r = mobile.padEl.getBoundingClientRect();
      const cx = r.left + r.width * 0.5;
      const cy = r.top + r.height * 0.5;
      mobile.center.x = cx; mobile.center.y = cy;
      const maxR = Math.min(r.width, r.height) * 0.5 * 0.85;
      let dx = clientX - cx;
      let dy = clientY - cy;
      const len = Math.hypot(dx, dy) || 1;
      const cl = Math.min(len, maxR);
      dx = dx / len * cl;
      dy = dy / len * cl;
      if (mobile.stickEl) {
         mobile.stickEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      }
      mobile.move.x = dx / maxR;
      mobile.move.y = -dy / maxR;
   }

   // Left pad handlers
   function onJoyDown(e){ e.preventDefault(); mobile.touching = true; mobile.id = e.pointerId || 'p'; updateStick(e.clientX, e.clientY); }
   function onJoyMove(e){ if (!mobile.touching) return; if ((e.pointerId || 'p') !== mobile.id) return; e.preventDefault(); updateStick(e.clientX, e.clientY); }
   function onJoyUp(e){ if ((e.pointerId || 'p') !== mobile.id) return; e.preventDefault(); mobile.touching = false; mobile.id = null; mobile.move.x = 0; mobile.move.y = 0; if (mobile.stickEl) mobile.stickEl.style.transform = 'translate(-50%, -50%)'; }
   if (mobile.padEl) {
      mobile.padEl.addEventListener('pointerdown', onJoyDown, { passive: false });
      window.addEventListener('pointermove', onJoyMove, { passive: false });
      window.addEventListener('pointerup', onJoyUp, { passive: false });
      window.addEventListener('pointercancel', onJoyUp, { passive: false });
   }

   // Fire button
   if (mobile.fireBtn) {
      mobile.fireBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); mobile.firing = true; fireBullet(); }, { passive: false });
      const stopFire = (e)=>{ if (e) e.preventDefault(); mobile.firing = false; };
      mobile.fireBtn.addEventListener('pointerup', stopFire, { passive: false });
      mobile.fireBtn.addEventListener('pointercancel', stopFire, { passive: false });
      mobile.fireBtn.addEventListener('pointerleave', stopFire, { passive: false });
   }

   // Look swipe on the canvas (ignore when starting on controls)
   function isControlElement(el){ return !!(el && el.closest && el.closest('.mobile-controls')); }
   function onLookDown(e){ if (isControlElement(e.target)) return; e.preventDefault(); mobile.lookId = e.pointerId || 'l'; mobile.prevLook.x = e.clientX; mobile.prevLook.y = e.clientY; }
   function onLookMove(e){ if ((e.pointerId || 'l') !== mobile.lookId) return; e.preventDefault(); const dx = e.clientX - mobile.prevLook.x; const dy = e.clientY - mobile.prevLook.y; mobile.prevLook.x = e.clientX; mobile.prevLook.y = e.clientY; mobile.lookDelta.x += dx; mobile.lookDelta.y += dy; }
   function onLookUp(e){ if ((e.pointerId || 'l') !== mobile.lookId) return; e.preventDefault(); mobile.lookId = null; }
   if (canvasEl) {
      canvasEl.addEventListener('pointerdown', onLookDown, { passive: false });
      window.addEventListener('pointermove', onLookMove, { passive: false });
      window.addEventListener('pointerup', onLookUp, { passive: false });
      window.addEventListener('pointercancel', onLookUp, { passive: false });
   }

   // Re-evaluate on resize/orientation
   const reevaluate = ()=>{ const t = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || window.matchMedia('(pointer: coarse)').matches; mobile.active = !!t; applyVisibility(); };
   window.addEventListener('resize', reevaluate);
   window.addEventListener('orientationchange', reevaluate);
}

function init() {
   scene = new THREE.Scene();
   canvas = renderer ? renderer.domElement : document.querySelector('canvas');

   // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
   camera.position.set(0, 30, 120);
   // Set up a slow orbit around the Earth (around Y axis) for non-flight mode
   const rXZ = Math.hypot(camera.position.x, camera.position.z);
   const theta0 = Math.atan2(camera.position.z, camera.position.x);
   cameraOrbit = { radius: rXZ, theta: theta0, speed: 0.02, height: camera.position.y };
   // Slight diagonal tilt (incline orbit plane a bit around X)
   cameraOrbit.tilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(12));

   // Renderer
   renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Better color management for textures
      renderer.outputEncoding = THREE.sRGBEncoding;
   renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
   document.getElementById('container').appendChild(renderer.domElement);
   // Setup mobile controls after DOM available
   setupMobileControls();

   // No orbit controls per request (camera is static)

   // Lights: ambient + sun + rim + hemisphere for "epic" contrast
      scene.add(new THREE.AmbientLight(0x303030, 0.5));
      const sun = new THREE.DirectionalLight(0xffffff, 1.6);
      sun.position.set(120, 60, 80);
      scene.add(sun);

      const rim = new THREE.DirectionalLight(0xfff0e0, 0.6);
      rim.position.set(-80, -30, -70);
      scene.add(rim);

      const hemi = new THREE.HemisphereLight(0x445566, 0x000011, 0.4);
      scene.add(hemi);

   // Distant Sun with lens flare and point light
   createSun();

   // Trail texture for ship glow
   trailTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png');
   // Initialize pooled explosions to avoid per-kill allocation spikes
   if (window.ExplosionSystem) {
      // Note: playSfx is defined later; at runtime init() is called after its definition
      window.ExplosionSystem.init(scene, trailTexture, cleanupQueue, (name, g)=>{ if (typeof playSfx === 'function') playSfx(name, g); });
   }
      // Bullet shared resources
      bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
      bulletMat = new THREE.MeshBasicMaterial({ color: 0x33b3ff, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false });
      // Enemy bullet resources
      enemyBulletGeom = new THREE.SphereGeometry(0.28, 8, 8);
      enemyBulletMat = new THREE.MeshBasicMaterial({ color: 0xff5533, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false });

   // Starfield background
   const starGeometry = new THREE.BufferGeometry();
      const starCount = 15000; // denser starfield
   const positions = new Float32Array(starCount * 3);
   for (let i = 0; i < starCount; i++) {
         const r = 2000 + Math.random() * 7000; // 2,000 .. 9,000 (within camera far 10,000)
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);
   }
   starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
   stars = new THREE.Points(starGeometry, starMaterial);
   scene.add(stars);

   // Create distant planets with lurking enemies
   createDistantPlanets();

   // Scatter turbo boost capsules and drifting asteroids in nearby space
   createBoostPickups();
   createAsteroids();

      // Earth: higher-res diffuse + specular maps; red emissive glow
   const texLoader = new THREE.TextureLoader();
   const diffuseTex = texLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
   const specularTex = texLoader.load('./3d/earth_specular.png');
      // sRGB for albedo/diffuse
      diffuseTex.encoding = THREE.sRGBEncoding;
   // Ensure equirectangular (2:1) maps 1:1 across sphere
   diffuseTex.wrapS = THREE.RepeatWrapping;
   specularTex.wrapS = THREE.RepeatWrapping;
   diffuseTex.repeat.set(1, 1);
   specularTex.repeat.set(1, 1);
   diffuseTex.offset.set(0, 0);
   specularTex.offset.set(0, 0);
   // Improve texture sharpness
   const maxAniso = renderer.capabilities.getMaxAnisotropy();
   diffuseTex.anisotropy = maxAniso;
   specularTex.anisotropy = maxAniso;
   // Optional longitudinal rotation (degrees) if you need to re-center continents
   const EARTH_LON_OFFSET_DEG = 0; // tweak if alignment is off
   const lonOffset = THREE.MathUtils.degToRad(EARTH_LON_OFFSET_DEG);
   [diffuseTex, specularTex].forEach(t => { t.center.set(0.5, 0.5); t.rotation = lonOffset; });

      const earthGeo = new THREE.SphereGeometry(20, 256, 128);
      const earthMat = new THREE.MeshPhongMaterial({
         map: diffuseTex,
         specularMap: specularTex,
         specular: new THREE.Color(0x333333),
         shininess: 35,
         emissive: new THREE.Color(0xff2030), // red glow
         emissiveMap: specularTex, // oceans/city lights drive emissive
         emissiveIntensity: 0.6
      });
      earth = new THREE.Mesh(earthGeo, earthMat);
      scene.add(earth);

         // Atmosphere: gradient rim glow via Fresnel-style shader (smooth, "blurred" halo)
            const atmoGeo = new THREE.SphereGeometry(20.75, 192, 96); // slightly larger, subtle halo
         const atmoMat = new THREE.ShaderMaterial({
             uniforms: {
                color: { value: new THREE.Color(0xff3030) },
                   intensity: { value: 1.0 },  // stronger red halo
                   power: { value: 2.6 }       // softer rim
             },
             vertexShader: `
                varying vec3 vWorldPosition;
                varying vec3 vWorldNormal;
                void main(){
                   vec4 wp = modelMatrix * vec4(position, 1.0);
                   vWorldPosition = wp.xyz;
                   // Transform normal to world space
                   vWorldNormal = normalize(mat3(modelMatrix) * normal);
                   gl_Position = projectionMatrix * viewMatrix * wp;
                }
             `,
             fragmentShader: `
                uniform vec3 color;
                uniform float intensity;
                uniform float power;
                varying vec3 vWorldPosition;
                varying vec3 vWorldNormal;
                void main(){
                   // View direction in world space
                   vec3 V = normalize(cameraPosition - vWorldPosition);
                   // Rim factor (Fresnel). BackSide mesh gives outward normals; use abs for robustness
                   float rim = 1.0 - max(0.0, dot(normalize(vWorldNormal), V));
                   rim = pow(rim, power);
                   // Color and alpha follow the rim for a soft gradient
                   vec3 glow = color * rim * intensity;
                   float alpha = rim * 0.85 * (intensity * 0.9);
                   gl_FragColor = vec4(glow, alpha);
                }
             `,
             transparent: true,
             blending: THREE.AdditiveBlending,
             depthWrite: false,
             side: THREE.BackSide
         });
         const atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
         earth.add(atmosphere);

      // Red beam: a very tall additive cylinder starting at Earth's north pole shooting along +Y
      const beamHeight = 4000;
   // Thinner beam (narrow radii). Top/bottom radii kept slightly different for a subtle taper.
   const beamGeom = new THREE.CylinderGeometry(0.6, 1.2, beamHeight, 48, 1, true);
      const beamMat = new THREE.MeshBasicMaterial({
         color: 0xff2030,
         transparent: true,
         opacity: 0.45,
         blending: THREE.AdditiveBlending,
         depthWrite: false,
         side: THREE.DoubleSide
      });
      beam = new THREE.Mesh(beamGeom, beamMat);
      // position so the bottom sits at y = earthRadius (north pole)
      beam.position.set(0, 20 + beamHeight / 2, 0);
      scene.add(beam);

      // Red point light near the beam base to add local glow on Earth
      redLight = new THREE.PointLight(0xff2030, 2.2, 600, 2);
      redLight.position.set(0, 30, 0);
      scene.add(redLight);

      // Load ship model then create ships on random orbits
   loadShipModel().then(() => createShips(12));

      // Postprocessing composer with bloom for glow
   composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.6, 0.12);
      composer.addPass(bloomPass);
      // Extremely subtle boost-only motion blur (disabled by default)
      afterimagePass = new THREE.AfterimagePass(0.9998);
      afterimagePass.enabled = false;
      composer.addPass(afterimagePass);
   // Vignette pass for boost effect (starts disabled with amount 0)
   vignettePass = createVignettePass();
         // Subtle boost distortion ("liquify") before vignette
         distortionPass = createBoostDistortionPass();
         composer.addPass(distortionPass);
         composer.addPass(vignettePass);
         // Speed lines overlay for boost sensation
         createSpeedLines();

      // Timing
   clock = new THREE.Clock();

   // Events
   window.addEventListener('resize', onWindowResize, false);

   animate();

   // Secret tap-to-unlock flight mode (tap title 5x)
   if (typeof setupSecretFlightMode === 'function') setupSecretFlightMode();
   // Prepare SFX system
   // Initialize SFX only after a user gesture to avoid autoplay warnings
   if (typeof setupSfx === 'function') {
      const initSfxOnce = ()=>{ setupSfx(); window.removeEventListener('pointerdown', initSfxOnce); window.removeEventListener('keydown', initSfxOnce); };
      window.addEventListener('pointerdown', initSfxOnce, { once: true });
      window.addEventListener('keydown', initSfxOnce, { once: true });
   }
   // Prepare damage FX overlay
   setupDamageFx();
}

async function loadShipModel() {
   return new Promise((resolve) => {
      const loader = new THREE.GLTFLoader();
      loader.load(
         SHIP_MODEL_URL,
         (gltf) => {
            shipGLTF = gltf.scene;
            // Rotate model so its nose points along -Z (Three.js lookAt aligns -Z toward target)
            shipGLTF.rotation.y = -Math.PI / 2;
            // Ensure PBR materials look right
            shipGLTF.traverse((obj) => {
               if (obj.isMesh && obj.material) {
                  if (obj.material.map) obj.material.map.encoding = THREE.sRGBEncoding;
                  obj.material.needsUpdate = true;
               }
            });
            resolve();
         },
         undefined,
         (err) => {
            console.warn('Ship model failed to load at', SHIP_MODEL_URL, err);
            shipGLTF = null; // fallback will use procedural box
            resolve();
         }
      );
   });
}

// Simple vignette shader pass for boost effect
function createVignettePass(){
   const VignetteShader = {
      uniforms: {
         tDiffuse: { value: null },
         amount: { value: 0.0 }, // 0..1
      },
      vertexShader: `
         varying vec2 vUv;
         void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
      fragmentShader: `
         uniform sampler2D tDiffuse;
         uniform float amount;
         varying vec2 vUv;
         void main(){
            vec4 col = texture2D(tDiffuse, vUv);
            // radial factor from center
            vec2 p = vUv * 2.0 - 1.0;
            float r = clamp(length(p), 0.0, 1.0);
            // ease curve for soft edges
            float vig = smoothstep(0.7, 1.0, r);
            // darken edges slightly and add a tiny warm tint on boost
            float dark = mix(1.0, 0.92, amount * vig);
            vec3 tint = mix(col.rgb, col.rgb * vec3(1.02, 0.98, 0.95), amount * vig * 0.6);
            gl_FragColor = vec4(tint * dark, col.a);
         }
      `
   };
   const pass = new THREE.ShaderPass(VignetteShader);
   pass.renderToScreen = false;
   return pass;
}

// Boost distortion pass: subtle radial warp for a "liquify" feel when boosting
function createBoostDistortionPass(){
   const DistortShader = {
      uniforms: {
         tDiffuse: { value: null },
         amount: { value: 0.0 }, // 0..1
         time: { value: 0.0 }
      },
      vertexShader: `
         varying vec2 vUv;
         void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
      fragmentShader: `
         uniform sampler2D tDiffuse;
         uniform float amount;
         uniform float time;
         varying vec2 vUv;
         // Simple pseudo-random
         float n3(vec2 p){ return fract(sin(dot(p, vec2(41.3, 289.1))) * 43758.5453); }
         void main(){
            vec2 uv = vUv;
            vec2 c = vec2(0.5);
            vec2 d = uv - c;
            float r = length(d);
            // Fisheye barrel distortion: expand radially with r^2 and r^4 terms
            float k = amount * 0.8;        // strength
            float r2 = r*r;
            float factor = 1.0 + k * r2 + 0.25 * k * k * r2 * r2;
            uv = c + d * factor;
            // Subtle center ripple on engage for impact
            float ripple = amount * 0.012 * sin(14.0 * r - time * 8.0);
            vec2 dir = d / max(1e-4, r);
            uv += dir * ripple;
            // Tiny noise wobble
            float wobble = (n3(uv * 120.0 + time) - 0.5) * amount * 0.0025;
            uv += vec2(wobble, -wobble);
            uv = clamp(uv, 0.0, 1.0);
            vec4 col = texture2D(tDiffuse, uv);
            gl_FragColor = col;
         }
      `
   };
   const pass = new THREE.ShaderPass(DistortShader);
   pass.renderToScreen = false;
   return pass;
}

// Speed dots (boost effect): a pool of small camera-facing dot sprites spawned near the ship
function createSpeedLines(){
   // Generate a circular dot texture (soft radial falloff)
   const size = { w: 32 , h: 32 };
   const canvas = document.createElement('canvas');
   canvas.width = size.w; canvas.height = size.h;
   const ctx = canvas.getContext('2d');
   const grd = ctx.createRadialGradient(size.w/2, size.h/2, 0, size.w/2, size.h/2, size.w/2);
   grd.addColorStop(0.0, 'rgba(255,255,255,1.0)');
   grd.addColorStop(0.6, 'rgba(255,255,255,0.6)');
   grd.addColorStop(1.0, 'rgba(255,255,255,0.0)');
   ctx.fillStyle = grd;
   ctx.fillRect(0, 0, size.w, size.h);
   const dotTex = new THREE.CanvasTexture(canvas);
   dotTex.minFilter = THREE.LinearFilter;
   dotTex.magFilter = THREE.LinearFilter;
   dotTex.wrapS = THREE.ClampToEdgeWrapping;
   dotTex.wrapT = THREE.ClampToEdgeWrapping;
   speedLines.texture = dotTex;

   const material = new THREE.SpriteMaterial({
      map: dotTex,
      color: 0xffffff,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: false,
      opacity: 0.0
   });
   const group = new THREE.Group();
   group.renderOrder = 999; // draw late
   scene.add(group);
   speedLines.group = group;
   const COUNT = 180;
   for (let i=0;i<COUNT;i++){
      const sp = new THREE.Sprite(material.clone());
      sp.scale.set(0.12, 0.12, 1);
      sp.visible = false;
      group.add(sp);
      speedLines.sprites.push({ sprite: sp, vel: 0, life: 0, maxLife: 1 });
   }
}

function updateSpeedLines(dt){
   if (!speedLines.group) return;
   // Determine activation from boostFx (global)
   const active = boostFx > 0.02;
   speedLines.active = active;
   speedLines.group.visible = active;
   if (!active) {
      // fade out smoothly
      for (const s of speedLines.sprites) {
         if (s.sprite.material.opacity > 0) {
            s.sprite.material.opacity = Math.max(0, s.sprite.material.opacity - dt * 2.5);
         }
      }
      return;
   }
   // Derive camera basis
   const q = camera.quaternion;
   const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(q);
   const right = new THREE.Vector3(1,0,0).applyQuaternion(q);
   const up = new THREE.Vector3(0,1,0).applyQuaternion(q);

   const minZ = 12, maxZ = 42; // distance ahead (closer since dots move sideways)
   const baseSpeed = 140, extra = 360; // units/sec along screen-plane
   const targetOpacity = 0.28 + 0.55 * THREE.MathUtils.clamp(boostFx, 0, 1);
   for (const s of speedLines.sprites) {
      const sp = s.sprite;
      if (s.life <= 0 || !sp.visible) {
         // respawn just ahead of camera, near the ship, then travel outward in a circular pattern
         const dz = THREE.MathUtils.lerp(minZ, maxZ, Math.random());
         const ang = Math.random() * Math.PI * 2;
         const r0 = 0.3 + Math.random()*1.6; // small initial radius around ship
         const pos = camera.position.clone()
            .add(fwd.clone().multiplyScalar(dz))
            .add(right.clone().multiplyScalar(Math.cos(ang) * r0))
            .add(up.clone().multiplyScalar(Math.sin(ang) * r0));
         sp.position.copy(pos);
         // Size dots to a roughly constant on-screen size based on depth and FOV
         const halfH = Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * dz;
         const screenFrac = 0.014 + 0.010 * (boostFx || 0) + Math.random()*0.004; // larger fraction for clarity
         const sizeWorld = THREE.MathUtils.clamp(screenFrac * 2 * halfH, 0.12, 2.8);
         sp.scale.set(sizeWorld, sizeWorld, 1);
         s.ang = ang; // store screen-plane travel angle
         s.vel = (baseSpeed + extra * boostFx + Math.random()*120);
         s.maxLife = 0.45 + Math.random()*0.7; // 0.45..1.15s
         s.life = s.maxLife;
         sp.visible = true;
         sp.material.opacity = 0.0;
      } else {
         // move outward in the camera's screen plane from the ship/camera center
         const dir2d = right.clone().multiplyScalar(Math.cos(s.ang || 0)).add(up.clone().multiplyScalar(Math.sin(s.ang || 0)));
         sp.position.addScaledVector(dir2d, s.vel * dt);
         s.life -= dt;
      }
      // fade in/out
      const t = 1 - (s.life / s.maxLife);
      const o = (t < 0.2) ? (t/0.2) : (t > 0.8 ? (1 - t)/0.2 : 1);
      sp.material.opacity = THREE.MathUtils.clamp(o * targetOpacity, 0, 1);
      // if behind camera, force recycle
      const toCam2 = sp.position.clone().sub(camera.position);
      const screenRad = Math.abs(toCam2.dot(right)) + Math.abs(toCam2.dot(up));
      if (toCam2.dot(fwd) < -5 || screenRad > 120) {
         s.life = 0; sp.visible = false; sp.material.opacity = 0;
      }
   }
}

// Create a bright Sun with lens flare and light far away in the scene
function createSun(){
   const loader = new THREE.TextureLoader();
   const tex0 = loader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
   const tex3 = loader.load('https://threejs.org/examples/textures/lensflare/lensflare3.png');
   const sunPos = new THREE.Vector3(4200, 1800, -4200);

   // Soft halo billboard with smooth radial falloff to avoid any hard edge
   const glowGeo = new THREE.PlaneGeometry(1, 1);
   const glowMat = new THREE.ShaderMaterial({
      uniforms: {
         color: { value: new THREE.Color(0xffe4b5) },
         intensity: { value: 1.0 },
         power: { value: 2.6 }
      },
      vertexShader: `
         varying vec2 vUv;
         void main(){
           vUv = uv;
           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
         }
      `,
      fragmentShader: `
         uniform vec3 color;
         uniform float intensity;
         uniform float power;
         varying vec2 vUv;
         void main(){
           vec2 p = vUv * 2.0 - 1.0; // -1..1
           float r = length(p);
           float a = pow(max(0.0, 1.0 - r), power) * intensity;
           gl_FragColor = vec4(color * a, a);
         }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: false
   });
   sunGlow = new THREE.Mesh(glowGeo, glowMat);
   sunGlow.scale.set(1400, 1400, 1);
   sunGlow.position.copy(sunPos);
   scene.add(sunGlow);

   // Smaller, softer core sprite layered on top for a bright center picked up by bloom
   const coreMat = new THREE.SpriteMaterial({ map: tex0, color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false, depthTest: false });
   sunCore = new THREE.Sprite(coreMat);
   sunCore.scale.set(320, 320, 1);
   sunCore.position.copy(sunPos);
   scene.add(sunCore);

   // Point light to act as sun illumination in that direction
   sunLight = new THREE.PointLight(0xfff4d6, 1.35, 12000, 2);
   sunLight.position.copy(sunPos);
   scene.add(sunLight);

   // Lens flare chained to the light (slightly toned down sizes)
   const flare = new THREE.Lensflare();
   flare.addElement(new THREE.LensflareElement(tex0, 600, 0, new THREE.Color(0xffeedd)));
   flare.addElement(new THREE.LensflareElement(tex3, 100, 0.4));
   flare.addElement(new THREE.LensflareElement(tex3, 60, 0.7));
   flare.addElement(new THREE.LensflareElement(tex3, 80, 1.0));
   sunLight.add(flare);
}

// Small additive sprite "nav lights" on ships to improve visibility
// (Removed) Ship nav lights were sprite-based; no longer used for saucer enemies.

function createShips(count) {
   const rng = () => Math.random();
   for (let i = 0; i < count; i++) {
   // Radius with occasional larger orbits so ships can come closer to the camera line
   const radius = (rng() < 0.35) ? (90 + rng() * 70) : (35 + rng() * 85);
   // Mild eccentricity so ships sometimes move closer/farther
   const ecc = rng() * 0.35; // 0..0.35
   const eccPhase = rng() * Math.PI * 2;
      const speed = (rng() * 0.25 + 0.05) * (rng() < 0.5 ? -1 : 1); // radians/sec
      const phase = rng() * Math.PI * 2;

      // Random orbit plane
      const normal = new THREE.Vector3(rng() * 2 - 1, rng() * 2 - 1, rng() * 2 - 1).normalize();
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);

   // Enemy ship as a dark saucer: squashed sphere with a small top glow (sprite, no real light to avoid shader recompiles)
      const saucerGeo = new THREE.SphereGeometry(1.8, 28, 20);
      // black material with slight metalness
        const saucerMat = new THREE.MeshStandardMaterial({ color: 0x111122, metalness: 0.7, roughness: 0.4 });


      const mesh = new THREE.Mesh(saucerGeo, saucerMat);
      const s = 1.2 + rng() * 0.6; // 1.2 .. 1.8 overall size
      mesh.scale.set(s, 0.2 * s, s); // flatten Y for saucer shape
      scene.add(mesh);
      // Top glow sprite (lighter than a dynamic light)
      if (trailTexture) {
         const glowMat = new THREE.SpriteMaterial({ map: trailTexture, color: 0x88aaff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, depthTest: false, opacity: 0.85 });
         const glow = new THREE.Sprite(glowMat);
         glow.position.set(0, 1.0, 0);
         glow.scale.set(1.0, 1.0, 1);
         mesh.add(glow);
      }

      // Create a glow trail for this ship
   const trailLen = 96; // longer trail
      const trailPositions = new Float32Array(trailLen * 3);
      const trailColors = new Float32Array(trailLen * 3);
      // initialize with zeros and a red->dark gradient
      for (let j = 0; j < trailLen; j++) {
        const t = 1 - j / (trailLen - 1); // head bright, tail dark
        const idx = j * 3;
        trailPositions[idx] = 0; trailPositions[idx + 1] = 0; trailPositions[idx + 2] = 0;
        // bright red fading to near black
        trailColors[idx] = 1.0 * t;
        trailColors[idx + 1] = 0.1 * t;
        trailColors[idx + 2] = 0.15 * t;
      }
      const trailGeom = new THREE.BufferGeometry();
      trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      trailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
            const trailMat = new THREE.PointsMaterial({
        map: trailTexture,
               size: 1.2, // smaller points for tighter trails
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        color: 0xffffff,
        sizeAttenuation: true
      });
   const trail = new THREE.Points(trailGeom, trailMat);
      scene.add(trail);

   ships.push({ mesh, radius, ecc, eccPhase, speed, phase, q, trail: { len: trailLen, geom: trailGeom, positions: trailPositions, colors: trailColors }, trailObj: trail, prevPos: null, planetId: null, center: earth.position.clone(), active: true });
   }
}

function updateShips(elapsed) {
   for (const s of ships) {
   if (s.active === false) continue; // skip inactive pooled enemies
      const t = s.speed * elapsed + s.phase;
      // Apply eccentricity to vary distance over time
      const rNow = s.radius * (1 - 0.4 * s.ecc * Math.cos(t * 0.7 + s.eccPhase));
      const base = new THREE.Vector3(Math.cos(t) * rNow, Math.sin(t) * rNow, 0);
      base.applyQuaternion(s.q);
      const center = s.center || earth.position;
      const pos = base.add(center);
      s.mesh.position.copy(pos);

      // Face along actual velocity direction using previous position when available
      let vel = null;
      if (s.prevPos) {
        vel = pos.clone().sub(s.prevPos);
      } else {
        // fallback to analytical tangent for first frame
        vel = new THREE.Vector3(-Math.sin(t) * rNow, Math.cos(t) * rNow, 0).applyQuaternion(s.q);
      }
         if (vel.lengthSq() > 1e-6) {
            const forward = pos.clone().add(vel.normalize());
            s.mesh.lookAt(forward);
            // Apply fixed left yaw so the model's nose truly matches velocity direction
            s.mesh.quaternion.multiply(ENEMY_YAW_LEFT);
         }
      s.prevPos = pos.clone();

      // Update trail: shift positions down and write the new head position slightly behind the ship
   const tp = s.trail.positions;
      const len = s.trail.len;
      // shift: from tail to head
      for (let i = len - 1; i > 0; i--) {
        tp[i * 3] = tp[(i - 1) * 3];
        tp[i * 3 + 1] = tp[(i - 1) * 3 + 1];
        tp[i * 3 + 2] = tp[(i - 1) * 3 + 2];
      }
      let headPos = pos;
      if (vel && vel.lengthSq() > 1e-10) {
         const offset = 1.6 * (s.mesh.scale && s.mesh.scale.x ? s.mesh.scale.x : 1);
         const back = vel.clone().normalize().multiplyScalar(offset);
         headPos = pos.clone().sub(back);
      }
      tp[0] = headPos.x; tp[1] = headPos.y; tp[2] = headPos.z;
      s.trail.geom.attributes.position.needsUpdate = true;
   }
}

function animate() {
   requestAnimationFrame(animate);

   const now = clock.getElapsedTime();
   gameTime = now;
   const elapsed = now;
   const dt = Math.max(0.001, Math.min(0.05, now - (lastTime || now)));
   lastTime = now;

   // Subtle motions
   if (stars) {
      stars.rotation.y += 0.0003;
   }
   if (earth) {
      earth.rotation.y += 0.0008; // slow Earth spin
      // Subtle emissive flicker to make orange "fires" feel alive
      const base = 0.6, amp = 0.12, freq = 3.2;
      const eInt = base + amp * (0.5 + 0.5 * Math.sin(now * freq));
      if (earth.material && 'emissiveIntensity' in earth.material) {
         earth.material.emissiveIntensity = eInt;
      }
   }
   // Keep sun halo facing the camera for a perfect billboard
   if (sunGlow) {
      sunGlow.quaternion.copy(camera.quaternion);
   }
   // Update distortion time uniform
   if (distortionPass) {
      distortionPass.uniforms.time.value += dt;
   }
   updateShips(elapsed);

   // Process a few deferred cleanups per frame to avoid GC spikes
   if (cleanupQueue && cleanupQueue.length) {
      const n = Math.min(3, cleanupQueue.length);
      for (let i = 0; i < n; i++) {
         try { const fn = cleanupQueue.shift(); if (typeof fn === 'function') fn(); } catch(_){ }
      }
   }

      if (flightMode) {
         // Poll gamepad input
         if (window.GamepadController) window.GamepadController.poll();
         // Show/hide mobile controls based on gamepad connection
         const gamepadConnected = window.GamepadController && window.GamepadController.isConnected();
         if (mobile.active) {
            const controls = document.querySelector('.mobile-controls');
            if (controls) {
               controls.style.display = gamepadConnected ? 'none' : '';
               controls.setAttribute('aria-hidden', gamepadConnected ? 'true' : 'false');
            }
         }
         updateFlight(dt);
         updateSpeedLines(dt);
         updateBullets(dt);
         updateExplosions(dt);
         updateFlashes(dt);
         updateEnemiesFire(dt);
         updateEnemyBullets(dt);
         updatePickups(dt);
         updateAsteroids(dt);
         checkVictory();
      } else if (cameraOrbit && earth) {
         // Slow diagonal camera orbit around Earth when not in flight mode
         cameraOrbit.theta += cameraOrbit.speed * dt;
         const base = new THREE.Vector3(
           Math.cos(cameraOrbit.theta) * cameraOrbit.radius,
           0,
           Math.sin(cameraOrbit.theta) * cameraOrbit.radius
         );
         base.applyQuaternion(cameraOrbit.tilt);
         base.y += cameraOrbit.height; // keep average height while tilted
         camera.position.copy(base);
         camera.lookAt(earth.position);
      }

      // Apply camera shake at the end so it affects the final view
      if (shakeTime > 0) {
         const t = shakeTime / shakeDuration;
         const s = shakeMagnitude * t * t; // ease-out by squaring
         const rW = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
         const uW = new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion);
         const fW = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
         camera.position
            .addScaledVector(rW, (Math.random()*2-1) * 0.06 * s)
            .addScaledVector(uW, (Math.random()*2-1) * 0.05 * s)
            .addScaledVector(fW, (Math.random()*2-1) * 0.04 * s);
         const e = new THREE.Euler((Math.random()*2-1)*0.003*s, (Math.random()*2-1)*0.003*s, 0, 'YXZ');
         camera.quaternion.multiply(new THREE.Quaternion().setFromEuler(e));
         shakeTime = Math.max(0, shakeTime - dt);
      }

      // Damage flash fade
      if (damageFlashEl) {
         // Exponential decay
         damageFlashAlpha = Math.max(0, damageFlashAlpha * Math.exp(-dt * 6));
         damageFlashEl.style.backgroundColor = `rgba(255, 40, 20, ${0.55 * damageFlashAlpha})`;
      }

      // Overdrive HUD update
      if (typeof updateOverdriveBar === 'function') updateOverdriveBar();
      // Overheat HUD update
      if (typeof updateOverheatBar === 'function') updateOverheatBar();

      composer.render();
}
function onWindowResize() {
   camera.aspect = window.innerWidth / window.innerHeight;
   camera.updateProjectionMatrix();
   renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) {
         composer.setSize(window.innerWidth, window.innerHeight);
         if (bloomPass) bloomPass.setSize(window.innerWidth, window.innerHeight);
      }
}

// Fullscreen toggle
function toggleFullscreen() {
   if (!document.fullscreenElement) {
      // Enter fullscreen
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
         elem.requestFullscreen();
      } else if (elem.webkitRequestFullscreen) {
         elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
         elem.msRequestFullscreen();
      }
   } else {
      // Exit fullscreen
      if (document.exitFullscreen) {
         document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
         document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
         document.msExitFullscreen();
      }
   }
}

// Defer init() call until after helper functions (planets, curiosa) are defined
</script>
<script>
// Distant planets and curiosa handling
function createDistantPlanets(){
   const makePlanet = (id, pos, color, radius, enemyCount)=>{
      const geom = new THREE.SphereGeometry(radius, 32, 32);
      const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.0, roughness: 1.0, emissive: 0x000000 });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(pos);
      scene.add(mesh);
      const planet = { id, mesh, radius, enemies: [], revealed: false };
      planets.push(planet);
      // spawn a few enemies orbiting this planet
      const planeQ = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(Math.random(),Math.random(),Math.random()).normalize());
      for (let i=0;i<enemyCount;i++) {
         const sh = createPlanetEnemy(planet, planeQ);
         planet.enemies.push(sh);
      }
   };
   makePlanet('p1', new THREE.Vector3(3000, 1200, -3500), 0x6699ff, 140, 3);
   makePlanet('p2', new THREE.Vector3(-4200, -1800, 2800), 0xff8844, 180, 3);
   makePlanet('p3', new THREE.Vector3(5200, -900, 4300), 0x88ff66, 160, 2);
   makePlanet('p4', new THREE.Vector3(-5800, 2100, -4800), 0xbb88ff, 200, 4);
}

function createPlanetEnemy(planet, planeQ){
   // parameters
   const radius = 260 + Math.random()*220;
   const ecc = Math.random()*0.25;
   const eccPhase = Math.random()*Math.PI*2;
   const speed = (0.04 + Math.random()*0.12) * (Math.random()<0.5 ? -1 : 1);
   const phase = Math.random()*Math.PI*2;
   // mesh: dark saucer (squashed sphere) with a top light
   const saucerGeo = new THREE.SphereGeometry(1.8, 28, 20);
   const saucerMat = new THREE.MeshStandardMaterial({ color: 0x111122, metalness: 0.7, roughness: 0.4 });
   const mesh = new THREE.Mesh(saucerGeo, saucerMat);
   const s = 1.2 + Math.random() * 0.6; // match near-Earth saucers: 1.2..1.8
   mesh.scale.set(s, 0.2 * s, s); // flatter profile like near-Earth
   scene.add(mesh);
   // Top glow sprite instead of dynamic light (avoids shader recompiles)
   if (trailTexture) {
      const glowMat = new THREE.SpriteMaterial({ map: trailTexture, color: 0x88aaff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, depthTest: false, opacity: 0.85 });
      const glow = new THREE.Sprite(glowMat);
      glow.position.set(0, 1.0, 0);
      glow.scale.set(1.0, 1.0, 1);
      mesh.add(glow);
   }
   // trail
   const trailLen = 72;
   const trailPositions = new Float32Array(trailLen * 3);
   const trailColors = new Float32Array(trailLen * 3);
   for (let j=0;j<trailLen;j++){
      const t = 1 - j/(trailLen-1);
      const idx=j*3; trailPositions[idx]=0; trailPositions[idx+1]=0; trailPositions[idx+2]=0;
      trailColors[idx]=1.0*t; trailColors[idx+1]=0.25*t; trailColors[idx+2]=0.15*t;
   }
   const trailGeom = new THREE.BufferGeometry();
   trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
   trailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
   const trailMat = new THREE.PointsMaterial({ map: trailTexture, size: 1.1, transparent: true, depthWrite:false, blending: THREE.AdditiveBlending, vertexColors:true, color:0xffffff, sizeAttenuation:true });
   const trailObj = new THREE.Points(trailGeom, trailMat);
   scene.add(trailObj);

   const ship = { mesh, radius, ecc, eccPhase, speed, phase, q: planeQ, trail: { len: trailLen, geom: trailGeom, positions: trailPositions, colors: trailColors }, trailObj, prevPos:null, planetId: planet.id, center: planet.mesh.position.clone(), ai: { cooldown: 1.2, timer: Math.random()*1.2 }, active: true };
   ships.push(ship);
   return ship;
}

// Turbo boost pickups: glowing teal capsules that grant temporary overdrive
function spawnBoostPickupRandom(){
   const rng = Math.random;
   const baseOrigin = (earth && earth.position) ? earth.position : new THREE.Vector3(0,0,0);
   const r = 80 + rng()*1120; // Spread throughout space to distant planets
   const ang1 = rng()*Math.PI*2;
   const ang2 = (rng()*0.6 - 0.3);
   const pos = new THREE.Vector3(
      Math.cos(ang1)*r,
      Math.sin(ang2)*r*0.5,
      Math.sin(ang1)*r
   ).add(baseOrigin);
   // Capsule: cylinder + sphere caps
   const cyl = new THREE.CylinderGeometry(0.6, 0.6, 2.4, 16, 1, true);
   const mat = new THREE.MeshStandardMaterial({ color: 0x00ffee, emissive: 0x116677, emissiveIntensity: 1.2, metalness: 0.1, roughness: 0.25, transparent:true, opacity:0.95 });
   const body = new THREE.Mesh(cyl, mat);
   const capGeo = new THREE.SphereGeometry(0.6, 16, 12);
   const capTop = new THREE.Mesh(capGeo, mat);
   const capBot = new THREE.Mesh(capGeo, mat);
   capTop.position.y = 1.2; capBot.position.y = -1.2;
   body.add(capTop); body.add(capBot);
   body.position.copy(pos);
   body.rotation.x = rng()*Math.PI;
   body.rotation.y = rng()*Math.PI;
   // Flame sprites on ends
   if (trailTexture){
      const sm = new THREE.SpriteMaterial({ map: trailTexture, color: 0x55eaff, transparent:true, blending: THREE.AdditiveBlending, depthWrite:false, depthTest:false, opacity:0.9 });
      const s1 = new THREE.Sprite(sm.clone());
      const s2 = new THREE.Sprite(sm.clone());
      s1.position.set(0, 1.6, 0); s1.scale.set(1.2, 1.2, 1);
      s2.position.set(0,-1.6, 0); s2.scale.set(1.2, 1.2, 1);
      body.add(s1); body.add(s2);
   }
   scene.add(body);
   pickups.push({ mesh: body, radius: 1.2, t: rng()*Math.PI*2, origin: baseOrigin.clone(), baseRadius: 0 });
}

function createBoostPickups(){
   const count = 14;
   for (let i=0;i<count;i++) spawnBoostPickupRandom();

   // Also spawn turbos around each distant planet
   if (planets && planets.length) {
      for (const planet of planets) {
         const countPerPlanet = 3;
         for (let i=0;i<countPerPlanet;i++) {
            spawnBoostPickupNearPlanet(planet);
         }
      }
   }
}

function spawnBoostPickupAt(originVec, baseRadius){
   const rng = Math.random;
   const r = (baseRadius||200) + rng()*350; // Orbit ring thickness
   const ang1 = rng()*Math.PI*2;
   const ang2 = (rng()*0.6 - 0.3);
   const pos = new THREE.Vector3(
      Math.cos(ang1)*r,
      Math.sin(ang2)*r*0.5,
      Math.sin(ang1)*r
   ).add(originVec);
   // Capsule: cylinder + sphere caps
   const cyl = new THREE.CylinderGeometry(0.6, 0.6, 2.4, 16, 1, true);
   const mat = new THREE.MeshStandardMaterial({ color: 0x00ffee, emissive: 0x116677, emissiveIntensity: 1.2, metalness: 0.1, roughness: 0.25, transparent:true, opacity:0.95 });
   const body = new THREE.Mesh(cyl, mat);
   const capGeo = new THREE.SphereGeometry(0.6, 16, 12);
   const capTop = new THREE.Mesh(capGeo, mat);
   const capBot = new THREE.Mesh(capGeo, mat);
   capTop.position.y = 1.2; capBot.position.y = -1.2;
   body.add(capTop); body.add(capBot);
   body.position.copy(pos);
   body.rotation.x = rng()*Math.PI;
   body.rotation.y = rng()*Math.PI;
   // Flame sprites on ends
   if (trailTexture){
      const sm = new THREE.SpriteMaterial({ map: trailTexture, color: 0x55eaff, transparent:true, blending: THREE.AdditiveBlending, depthWrite:false, depthTest:false, opacity:0.9 });
      const s1 = new THREE.Sprite(sm.clone());
      const s2 = new THREE.Sprite(sm.clone());
      s1.position.set(0, 1.6, 0); s1.scale.set(1.2, 1.2, 1);
      s2.position.set(0,-1.6, 0); s2.scale.set(1.2, 1.2, 1);
      body.add(s1); body.add(s2);
   }
   scene.add(body);
   pickups.push({ mesh: body, radius: 1.2, t: rng()*Math.PI*2, origin: originVec.clone(), baseRadius: baseRadius||200 });
}

function spawnBoostPickupNearPlanet(planet){
   const center = planet.mesh.position;
   const base = (planet && typeof planet.radius === 'number' ? planet.radius : 120) + 180;
   spawnBoostPickupAt(center, base);
}

function updatePickups(dt){
   // Handle respawns
   if (pickupRespawns.length && typeof gameTime === 'number'){
      for (let i = pickupRespawns.length - 1; i >= 0; i--){
         if (gameTime >= pickupRespawns[i].at){
            const ri = pickupRespawns[i];
            if (ri.origin) {
               spawnBoostPickupAt(ri.origin, ri.baseRadius);
            } else {
               spawnBoostPickupRandom();
            }
            pickupRespawns.splice(i, 1);
         }
      }
   }

   for (let i = pickups.length - 1; i >= 0; i--){
      const p = pickups[i];
      p.t += dt;
      p.mesh.rotation.y += dt * 1.0;
      const pulse = 0.85 + 0.25*Math.sin(p.t*3.2);
      p.mesh.scale.setScalar(pulse);
      // Collision with player (camera)
      const d = camera.position.distanceTo(p.mesh.position);
      if (d < (p.radius + 2.2)){
         // Spark + SFX
         spawnFlash(p.mesh.position.clone(), 10, 0x66ddff);
         playSfx('boost', 0.8);
         // Temporary overdrive
         engine.pickupBoostTimer = Math.max(0, (engine.pickupBoostTimer||0)) + 3.0;
         engine.pickupBoostMax = Math.max(engine.pickupBoostMax||0, engine.pickupBoostTimer);
         // Remove pickup
         scene.remove(p.mesh);
         pickups.splice(i,1);
         // Respawn later near the same origin if available
         if (typeof gameTime === 'number') {
            const baseRadius = (p.baseRadius !== undefined) ? p.baseRadius : 0;
            pickupRespawns.push({ at: gameTime + 12, origin: p.origin || null, baseRadius });
         }
      }
   }
}

// Field of brown asteroids drifting around
function spawnAsteroidAt(pos, origin, size){
   const rng = Math.random;
   const s = size || (rng()*3 + 1.5);
   const geo = new THREE.IcosahedronGeometry(s, 1);
   const arr = geo.attributes.position.array;
   for (let j=0;j<arr.length; j+=3){
      const n = (rng()*0.5 + 0.75);
      arr[j] *= n; arr[j+1]*=n; arr[j+2]*=n;
   }
   geo.attributes.position.needsUpdate = true;
   geo.computeVertexNormals();
   const mat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.95, metalness: 0.02 });
   const m = new THREE.Mesh(geo, mat);
   m.position.copy(pos);
   m.rotation.set(rng()*Math.PI, rng()*Math.PI, rng()*Math.PI);
   const vel = new THREE.Vector3((rng()-0.5)*2, (rng()-0.5)*1.2, (rng()-0.5)*2);
   scene.add(m);
   const radius = s * 1.0; // approximate collision radius based on size
   asteroids.push({ mesh:m, radius, size:s, vel, rot: new THREE.Vector3((rng()-0.5)*0.4, (rng()-0.5)*0.4, (rng()-0.5)*0.4), origin: origin ? origin.clone() : ((earth && earth.position) ? earth.position.clone() : new THREE.Vector3(0,0,0)) });
}

function createAsteroids(){
   const rng = Math.random;

   // Asteroids scattered from Earth throughout space
   const countEarth = 22;
   const baseOrigin = (earth && earth.position) ? earth.position : new THREE.Vector3(0,0,0);
   for (let i=0;i<countEarth;i++){
      const r = 120 + rng()*1280;
      const ang1 = rng()*Math.PI*2;
      const ang2 = (rng()*0.8 - 0.4);
      const pos = new THREE.Vector3(
         Math.cos(ang1)*r,
         Math.sin(ang2)*r*0.6,
         Math.sin(ang1)*r
      ).add(baseOrigin);
      spawnAsteroidAt(pos, baseOrigin);
   }

   // Asteroids around each distant planet
   if (planets && planets.length) {
      for (const planet of planets) {
         const countPerPlanet = 12;
         const center = planet.mesh.position;
         for (let i=0;i<countPerPlanet;i++){
            const r = planet.radius + 200 + rng()*400;
            const ang1 = rng()*Math.PI*2;
            const ang2 = (rng()*0.6 - 0.3);
            const pos = new THREE.Vector3(
               Math.cos(ang1)*r,
               Math.sin(ang2)*r*0.5,
               Math.sin(ang1)*r
            ).add(center);
            spawnAsteroidAt(pos, center);
         }
      }
   }
}

function breakAsteroid(a){
   // Only break very large asteroids
   if (!a || !a.size || a.size < 3.2) return;
   const rng = Math.random;
   const fragments = 3 + Math.floor(rng()*3); // 3..5
   const origin = a.origin || ((earth && earth.position) ? earth.position : new THREE.Vector3(0,0,0));
   const centerDir = a.mesh.position.clone().sub(origin).normalize();
   for (let i=0;i<fragments;i++){
      const fracSize = Math.max(0.6, (a.size * 0.4) + rng()*0.6); // smaller than parent
      const offset = centerDir.clone().multiplyScalar(0.5 + rng()*0.8).add(new THREE.Vector3((rng()-0.5)*0.6,(rng()-0.5)*0.6,(rng()-0.5)*0.6));
      const pos = a.mesh.position.clone().add(offset);
      spawnAsteroidAt(pos, origin, fracSize);
      // Adjust the just-spawned asteroid's velocity to head away from center
      const child = asteroids[asteroids.length - 1];
      if (child) {
         const away = centerDir.clone().multiplyScalar(2.5 + rng()*2.5);
         child.vel.add(away);
      }
   }
}

function updateAsteroids(dt){
   for (let i = asteroids.length - 1; i >= 0; i--){
      const a = asteroids[i];
      a.mesh.position.addScaledVector(a.vel, dt);
      a.mesh.rotation.x += a.rot.x * dt;
      a.mesh.rotation.y += a.rot.y * dt;
      a.mesh.rotation.z += a.rot.z * dt;
      // Wrap far from the asteroid's origin to keep field dense
      const origin = (a.origin) ? a.origin : ((earth && earth.position) ? earth.position : new THREE.Vector3(0,0,0));
      const d = a.mesh.position.distanceTo(origin);
      if (d > 1600){
         const dir = a.mesh.position.clone().sub(origin).normalize();
         a.mesh.position.copy(origin).add(dir.multiplyScalar(400));
      }
      // Player collision
      const pd = camera.position.distanceTo(a.mesh.position);
      if (pd < a.radius + 2.0){
         // Damage and destroy asteroid
         playerHealth = Math.max(0, playerHealth - 5);
         onPlayerDamaged(5);
         updateHealthbar(playerHealth);
         const explodePos = a.mesh.position.clone();
         spawnExplosion(explodePos);
         spawnFlash(explodePos, 8, 0xff8844);
         playSfx('explosion', 0.8);
         // Break large asteroids into fragments moving away from center
         breakAsteroid(a);
         // Remove asteroid
         scene.remove(a.mesh);
         if (a.mesh.geometry) a.mesh.geometry.dispose();
         if (a.mesh.material) a.mesh.material.dispose();
         asteroids.splice(i, 1);
         if (playerHealth <= 0) { setTimeout(()=>location.reload(), 150); }
      }
   }
}

const revealedPlanets = new Set();
function maybeShowCuriosa(planetId){
   if (revealedPlanets.has(planetId)) return;
   // any ships remaining for this planet?
   for (const s of ships){ if (s.planetId === planetId && s.active !== false) return; }
   revealedPlanets.add(planetId);
   const text = curiosa[planetId] || 'Unknown';
   showCuriosaModal(text);
}

function showCuriosaModal(text){
   let el = document.getElementById('curiosaModal');
   if (!el){
      el = document.createElement('div');
      el.id = 'curiosaModal';
      el.className = 'modal-backdrop';
      el.innerHTML = `<div class="modal-card"><h2>Discovery</h2><p id="curiosaText"></p><div class="modal-actions"><button id="curiosaOk">OK</button></div></div>`;
      document.body.appendChild(el);
   }
   el.style.display='';
   const p = el.querySelector('#curiosaText'); if (p) p.textContent = text;
   const btn = el.querySelector('#curiosaOk');
   if (btn) {
      btn.onclick = ()=>{ el.style.display='none'; };
      // Enable Enter key
      if (typeof enableEnterKey === 'function') {
         enableEnterKey(el, btn);
      }
   }
}
   // Now that helpers exist, run init
   init();
   setupFullscreenToggle();
// Background YouTube audio (hidden player)
let ytPlayer = null;
let ytReady = false;
let ytPlayWhenReady = false;
let ytLoopInterval = null;

function createYouTubePlayer(){
   if (ytPlayer || !(window.YT && YT.Player)) return;
   ytPlayer = new YT.Player('yt-holder', {
      height: '1',
      width: '1',
      videoId: 'gWkT7Mb3zAE', // NeoFuture
      playerVars: {
         autoplay: 0,
         controls: 0,
         rel: 0,
         modestbranding: 1,
         playsinline: 1,
         origin: location.origin
      },
      events: {
         onReady: (e) => {
            ytReady = true;
            if (ytPlayWhenReady) {
               try { e.target.setVolume(30); e.target.playVideo(); } catch(_){ }
               ytPlayWhenReady = false;
            }
            ensureYtLoop();
         },
         onStateChange: (e) => {
            // Auto-resume if paused or ended (state 2 = paused, 0 = ended)
            if (e.data === 2 || e.data === 0) {
               try {
                  ytPlayer.seekTo(0, true);
                  ytPlayer.playVideo();
               } catch(_){}
            }
         }
      }
   });
}

// Damage FX helpers
function setupDamageFx(){
   damageFlashEl = document.getElementById('damageFlash');
}

// Healthbar helper: updates fill width, label, and low-health styling
function updateHealthbar(value){
   const hb = document.getElementById('healthbar');
   if (!hb) return;
   const fill = hb.querySelector('.fill');
   const label = hb.querySelector('.label');
   const v = Math.max(0, Math.min(100, Math.round(value)));
   if (fill) fill.style.width = v + '%';
   if (label) label.textContent = String(v);
   hb.classList.toggle('low', v <= 30);
}

// Overheat HUD helper: shows/hides and updates fill based on weapon heat
function updateOverheatBar(){
//    const el = document.getElementById('overheat');
//    if (!el) return;
//    const fill = el.querySelector('.fill');
//    const heatPercent = Math.round(weaponHeat * 100);
//    if (fill) fill.style.width = heatPercent + '%';
//    el.classList.toggle('overheated', weaponOverheated);
//    // Show bar when in flight mode
//    if (flightMode) {
//       el.style.display = 'block';
//       el.setAttribute('aria-hidden', 'false');
//    } else {
//       el.style.display = 'none';
//       el.setAttribute('aria-hidden', 'true');
//    }
}

// Overdrive HUD helper: shows/hides and updates fill based on pickup overdrive timer
function updateOverdriveBar(){
   const el = document.getElementById('overdrive');
   if (!el || !engine) return;
   const fill = el.querySelector('.fill');
   const timer = Math.max(0, engine.pickupBoostTimer || 0);
   // Track the peak during the current chain for normalization
   if (timer > 0) {
      engine.pickupBoostMax = Math.max(engine.pickupBoostMax || 0, timer);
   } else {
      // Reset peak when expired so next activation uses a fresh scale
      engine.pickupBoostMax = 0;
   }
   const maxSpan = Math.max(0.001, engine.pickupBoostMax || 3.0);
   const pct = Math.max(0, Math.min(100, (timer / maxSpan) * 100));
   if (fill) fill.style.width = pct + '%';
   const visible = timer > 0.0;
   el.style.display = visible ? 'block' : 'none';
   el.setAttribute('aria-hidden', visible ? 'false' : 'true');
}

function onPlayerDamaged(amount){
   // Flash intensity and shake scale with damage amount
   damageFlashAlpha = Math.min(1, damageFlashAlpha + (amount * 0.04));
   shakeTime = Math.min(shakeDuration, shakeTime + 0.10 + amount * 0.004);
   shakeMagnitude = Math.min(1.0, 0.4 + amount * 0.03);
}

// Start message banner shown on entering flight mode
function showStartMessage(){
   const id = 'startMessage';
   let el = document.getElementById(id);
   if (!el){
      el = document.createElement('div');
      el.id = id;
      el.style.position = 'fixed';
      el.style.left = '50%';
      el.style.top = '18%';
      el.style.transform = 'translate(-50%, -50%)';
      el.style.zIndex = '50';
      el.style.pointerEvents = 'none';
      el.style.padding = '12px 16px';
      el.style.borderRadius = '10px';
      el.style.border = '1px solid rgba(51,179,255,0.5)';
      el.style.background = 'rgba(10,10,14,0.75)';
      el.style.color = '#cfeeff';
      el.style.fontFamily = "'VT323', monospace";
      el.style.fontSize = '24px';
      el.style.boxShadow = '0 0 22px rgba(51,179,255,0.6), 0 0 46px rgba(26,120,190,0.35)';
      el.style.opacity = '0';
      el.style.transition = 'opacity 240ms ease';
      document.body.appendChild(el);
   }
   el.textContent = 'Ghostis forces are invading earth, get away before they shoot at your ship. Eliminate all the enemies in the universe to unlock new data.';
   requestAnimationFrame(()=>{ el.style.opacity = '1'; });
   setTimeout(()=>{ el.style.opacity = '0'; setTimeout(()=>{ if (el && el.parentNode) el.parentNode.removeChild(el); }, 400); }, 2600);
}

window.onYouTubeIframeAPIReady = function(){
   // Ensure a player exists as soon as API is ready
   createYouTubePlayer();
};

function startBackgroundYouTube(){
   // Ensure player exists
   if (!ytPlayer) createYouTubePlayer();
   if (ytPlayer && ytReady) {
      try { ytPlayer.setVolume(30); ytPlayer.playVideo(); } catch(_){/* ignore */}
      ensureYtLoop();
   } else {
      ytPlayWhenReady = true;
   }
}

function ensureYtLoop(){
   if (ytLoopInterval) return;
   ytLoopInterval = setInterval(()=>{
      try {
         if (!ytPlayer || !ytReady || !ytPlayer.getCurrentTime) return;
         const t = ytPlayer.getCurrentTime();
         if (t >= 90) {
            ytPlayer.seekTo(0, true);
            ytPlayer.playVideo();
         }
      } catch(_){}
   }, 1000);
}

// Local audio playback for NeoFuture (requires you to place ./audio/neofuture.mp3)
(function(){
   const btn = document.getElementById('playNeo');
   if (!btn) return;
   const audio = new Audio('./audio/neofuture.mp3');
   audio.preload = 'none';
   audio.volume = 0.45; // lower background music volume for local audio
   let playing = false;
   btn.addEventListener('click', async () => {
      try {
         if (!playing) {
            await audio.play();
            playing = true;
            btn.textContent = 'Pause NeoFuture';
         } else {
            audio.pause();
            playing = false;
            btn.textContent = 'Play NeoFuture';
         }
      } catch (e) {
         // Likely file missing or autoplay blocked; guide user to Spotify
         btn.textContent = 'Use Spotify (no local file)';
      }
   });
   audio.addEventListener('ended', ()=>{
      playing = false;
      btn.textContent = 'Play NeoFuture';
   });
})();

// Hover SFX: lightweight synth "sci-fi" beep on button/icon hover
(function(){
   let ctx = null;
   let unlocked = false;
   function ensureCtx(){
      if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === 'suspended') ctx.resume();
   }
   function unlock(){
      ensureCtx();
      unlocked = true;
      window.removeEventListener('pointerdown', unlock);
   }
   window.addEventListener('pointerdown', unlock, { once: true });

   function playHoverBeep(){
      ensureCtx();
      if (!ctx || ctx.state !== 'running') return;
      const t0 = ctx.currentTime;
      const dur = 0.08; // 80ms
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(1400, t0);
      osc.frequency.exponentialRampToValueAtTime(1520, t0 + dur);
      gain.gain.setValueAtTime(0.0001, t0);
      gain.gain.exponentialRampToValueAtTime(0.12, t0 + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      osc.connect(gain).connect(ctx.destination);
      osc.start(t0);
      osc.stop(t0 + dur + 0.005);
   }

   function bindHover(selector){
      document.querySelectorAll(selector).forEach(el => {
         el.addEventListener('mouseenter', playHoverBeep);
         el.addEventListener('focus', playHoverBeep);
      });
   }
   bindHover('.corner-links a, .audio-widget button, .logo-fixed');
})();

   // SFX loader and helpers
   function setupSfx(){
      if (window.__sfxInitialized) return; // idempotent
      window.__sfxInitialized = true;
      function ensureCtx(){ if (!sfxCtx) sfxCtx = new (window.AudioContext||window.webkitAudioContext)(); return sfxCtx; }
      function reverseAudioBuffer(ctx, buf){
         try {
            const numCh = buf.numberOfChannels;
            const out = ctx.createBuffer(numCh, buf.length, buf.sampleRate);
            for (let ch=0; ch<numCh; ch++){
               const src = buf.getChannelData(ch);
               const dst = out.getChannelData(ch);
               for (let i=0, j=src.length-1; i<src.length; i++, j--){ dst[i] = src[j]; }
            }
            return out;
         } catch(_) { return null; }
      }
      async function loadBuffer(url){
         try {
            const ctx = ensureCtx();
            const resp = await fetch(url);
            const arr = await resp.arrayBuffer();
            return await ctx.decodeAudioData(arr);
         } catch (e){ return null; }
      }
      // Unlock on first user interaction
      const unlock = ()=>{ ensureCtx(); if (sfxCtx.state==='suspended') sfxCtx.resume(); window.removeEventListener('pointerdown', unlock); window.removeEventListener('keydown', unlock); window.removeEventListener('mousedown', unlock); };
      window.addEventListener('pointerdown', unlock, { once: true });
      window.addEventListener('keydown', unlock, { once: true });
      window.addEventListener('mousedown', unlock, { once: true });
      // Kick off buffer loads (local files expected to exist)
      loadBuffer('./audio/scificlick.wav').then(buf=>{ sfx.click = buf; });
      loadBuffer('./audio/laser-shot.wav').then(buf=>{ sfx.laser = buf; });
      loadBuffer('./audio/explosion.wav').then(buf=>{ sfx.explosion = buf; });
   // Optional whoosh for boost engage + reversed for release
   loadBuffer('./audio/boost.wav').then(buf=>{ sfx.boost = buf; const ctx = ensureCtx(); sfx.boostRev = buf ? reverseAudioBuffer(ctx, buf) : null; });
   }

   function playSfx(name, gain=0.9){
      if (!sfxCtx || sfxCtx.state!=='running') return;
      const buf = sfx[name];
      if (!buf) return; // not loaded yet
      const src = sfxCtx.createBufferSource();
      src.buffer = buf;
      // Randomize pitch slightly so repeated SFX don't sound identical
      src.playbackRate.value = 0.96 + Math.random() * 0.1; // ~ ±5%
      const g = sfxCtx.createGain();
      g.gain.value = gain;
      src.connect(g).connect(sfxCtx.destination);
      src.start();
      // Fade out at the end to prevent clipping (last 50ms)
      const duration = buf.duration;
      const fadeOutTime = 0.05; // 50ms
      if (duration > fadeOutTime) {
         g.gain.setValueAtTime(gain, sfxCtx.currentTime + duration - fadeOutTime);
         g.gain.linearRampToValueAtTime(0, sfxCtx.currentTime + duration);
      }
   }

   // Quick synthetic low boom for boost engage (no external asset required)
   window.playBoom = function(intensity=0.8){
      if (!sfxCtx) return;
      const ctx = sfxCtx;
      const now = ctx.currentTime;
      if (!isFinite(intensity) || intensity <= 0) intensity = 0.8;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const lowpass = ctx.createBiquadFilter();
      lowpass.type = 'lowpass';
      lowpass.frequency.setValueAtTime(380, now);
      osc.type = 'sine';
      // pitch drop (use linear ramps to avoid non-finite exponential constraints)
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.linearRampToValueAtTime(80, now + 0.22);
      // envelope (setTargetAtTime avoids exponential non-finite constraints)
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.setTargetAtTime(0.35 * intensity, now, 0.012);
      gain.gain.setTargetAtTime(0.0001, now + 0.06, 0.09);
      osc.connect(lowpass).connect(gain).connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.32);
   };

   // Helper function to enable Enter key on modal buttons
   function enableEnterKey(modal, button) {
      const handleEnter = (e) => {
         if (e.key === 'Enter' && modal.style.display !== 'none') {
            e.preventDefault();
            button.click();
         }
      };
      window.addEventListener('keydown', handleEnter);
      // Cleanup when modal is closed
      const originalDisplay = modal.style.display;
      const observer = new MutationObserver(() => {
         if (modal.style.display === 'none' && originalDisplay !== 'none') {
            window.removeEventListener('keydown', handleEnter);
            observer.disconnect();
         }
      });
      observer.observe(modal, { attributes: true, attributeFilter: ['style'] });
   }

   // Intro modal logic: open Spotify and play click SFX
   (function(){
      const modal = document.getElementById('readyModal');
      const btn = document.getElementById('readyBtn');
      if (!modal || !btn) return;
      btn.addEventListener('click', ()=>{
         playSfx('click', 0.8);
         modal.style.display = 'none';
         // Start hidden YouTube playback (user gesture compliant)
         startBackgroundYouTube();
      });
      // Enable Enter key
      enableEnterKey(modal, btn);
   })();

// ===== Secret Flight Mode implementation =====
function setupSecretFlightMode(){
   if (window.__flightBound) return; // idempotent
   window.__flightBound = true;
   const title = document.querySelector('.terminal h1');
   if (!title) return;
   let taps = 0;
   let tapTimer = null;
   title.addEventListener('click', () => {
      taps++;
      if (taps >= 5) {
         taps = 0;
         enterFlightMode();
      }
      clearTimeout(tapTimer);
      tapTimer = setTimeout(() => { taps = 0; }, 1500);
   });

   // Also allow one-click activation via the logo
   const logo = document.querySelector('.logo-fixed');
   if (logo) {
      logo.addEventListener('click', () => enterFlightMode());
   }
}

function enterFlightMode(){
   if (flightMode) return;
   flightMode = true;
   score = 0;
   // Reset weapon heat
   weaponHeat = 0;
   weaponOverheated = false;
   overheatCooldownTimer = 0;
   // Apply a short grace period before enemies are allowed to shoot
   enemyFireUnlockAt = (typeof gameTime === 'number' ? gameTime : 0) + 3.0; // seconds
   // On mobile, ensure the on-screen controls are visible
   if (mobile.active) {
      const controls = document.querySelector('.mobile-controls');
      if (controls) { controls.setAttribute('aria-hidden','false'); controls.style.display = ''; }
   }
   // Update HUD
   const hud = document.querySelector('.hud');
   if (hud) hud.textContent = `FLIGHT MODE — WASD move • Mouse aim • Click fire • Shift boost • F fullscreen — Score: 0 | Health: ${playerHealth}`;
   // Show healthbar
   updateHealthbar(playerHealth);
   const hb = document.getElementById('healthbar');
   if (hb) { hb.style.display = 'block'; hb.setAttribute('aria-hidden','false'); }

   // Start farther from the Earth to avoid instant crossfire
   if (earth && camera) {
      const dirOut = camera.position.clone().sub(earth.position).normalize();
      camera.position.add(dirOut.multiplyScalar(300));
   }

   // Try pointer lock on canvas to capture mouse for aim; allow re-lock on subsequent clicks
   const canvas = renderer.domElement;
   function lock(){ if (document.pointerLockElement !== canvas && canvas.requestPointerLock) canvas.requestPointerLock(); }
   canvas.addEventListener('click', lock);
   // Also allow clicking anywhere on the page to re-lock while in flight
   const relock = (e)=>{ if (flightMode && document.pointerLockElement !== canvas && canvas.requestPointerLock) { canvas.requestPointerLock(); } };
   document.addEventListener('click', relock);

   // Spawn player's ship (parent container) and attach visual model as child
   if (!playerShip) {
      playerShip = new THREE.Object3D();
      let playerModel;
      if (shipGLTF) {
         playerModel = shipGLTF.clone(true);
         playerModel.traverse((obj)=>{ if (obj.isMesh) obj.castShadow = obj.receiveShadow = false; });
         playerModel.scale.setScalar(1.8);
      } else {
         const pGeom = new THREE.BoxGeometry(2.0, 0.8, 4.0);
         const pMat = new THREE.MeshStandardMaterial({ color: 0x3bb3ff, emissive: 0x0b3a66, emissiveIntensity: 0.8, metalness: 0.1, roughness: 0.6 });
         playerModel = new THREE.Mesh(pGeom, pMat);
      }
      playerShip.add(playerModel);
      scene.add(playerShip);
   // Initialize position a bit in front of the camera
      const fwd0 = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
      playerShip.position.copy(camera.position).add(fwd0.multiplyScalar(10));
      playerShip.quaternion.copy(camera.quaternion);

   // Create engine glow sprites (left/right) as children of the ship parent (orange)
   const glowMat = new THREE.SpriteMaterial({ map: trailTexture, color: 0xff7a1a, transparent: true, opacity: 0.85, depthWrite: false, blending: THREE.AdditiveBlending });
   const glowL = new THREE.Sprite(glowMat.clone());
   const glowR = new THREE.Sprite(glowMat.clone());
   // Position behind the ship in parent local space (forward = -Z, engines at +Z)
   glowL.position.set(-0.45, -0.12, 1.6);
   glowR.position.set( 0.45, -0.12, 1.6);
   glowL.scale.set(0.35, 0.35, 0.35);
   glowR.scale.set(0.35, 0.35, 0.35);
   playerShip.add(glowL);
   playerShip.add(glowR);
      engineGlows = [glowL, glowR];

      // Player trail removed per request
      playerTrail = null;
   }

   // Hide overlay text when entering flight mode
   const overlay = document.querySelector('.overlay');
   if (overlay) overlay.style.display = 'none';

   // Arm enemy ships: give them simple AI fire timers
   for (const s of ships) {
      s.ai = s.ai || {};
      s.ai.cooldown = 0.7 + Math.random() * 1.4; // seconds between shots
      s.ai.timer = Math.random() * s.ai.cooldown; // desync starts
   }

   // Key listeners
   window.addEventListener('keydown', (e) => {
      // Fullscreen toggle (F key or F11)
      if (e.code === 'KeyF' || e.code === 'F11') {
         e.preventDefault();
         toggleFullscreen();
         return;
      }
      if (e.code === 'KeyW') keys.w = true;
      if (e.code === 'KeyA') keys.a = true;
      if (e.code === 'KeyS') keys.s = true;
      if (e.code === 'KeyD') keys.d = true;
      if (e.code === 'KeyQ') keys.q = true;
      if (e.code === 'KeyE') keys.e = true;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
         // Trigger boost SFX strictly on key press (not camera movement)
         if (!keys.shift) {
            keys.shift = true;
            if (!lastBoostSfxTime || (gameTime - lastBoostSfxTime) > 0.25) {
               playSfx('boost', 0.7);
               lastBoostSfxTime = gameTime;
            }
            boostPulse = 1.0;
            if (typeof window.playBoom === 'function') window.playBoom(0.9);
         } else {
            keys.shift = true;
         }
      }
   });
   window.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') keys.w = false;
      if (e.code === 'KeyA') keys.a = false;
      if (e.code === 'KeyS') keys.s = false;
      if (e.code === 'KeyD') keys.d = false;
      if (e.code === 'KeyQ') keys.q = false;
      if (e.code === 'KeyE') keys.e = false;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
         if (keys.shift) {
            keys.shift = false;
            if (!lastBoostReleaseSfxTime || (gameTime - lastBoostReleaseSfxTime) > 0.25) {
               playSfx('boostRev', 0.6);
               lastBoostReleaseSfxTime = gameTime;
            }
         }
      }
   });

   // Mouse look
   function onMouseMove(e){
      if (document.pointerLockElement === renderer.domElement) {
         const sens = 0.0025;
         yawTarget   -= e.movementX * sens;
         pitchTarget -= e.movementY * sens;
         pitchTarget = Math.max(-maxPitch, Math.min(maxPitch, pitchTarget));
      }
   }
   window.addEventListener('mousemove', onMouseMove);

   // Fire: continuous while mouse held
   window.addEventListener('mousedown', (e) => {
      if (e.button === 0) { mouseFiring = true; fireBullet(); }
   });
   window.addEventListener('mouseup', (e) => { if (e.button === 0) mouseFiring = false; });
   window.addEventListener('pointerup', () => { mouseFiring = false; });
   window.addEventListener('blur', () => { mouseFiring = false; });

   // Open Spotify search for the song in a new tab (within user gesture cascade)
   // Moved to intro modal acceptance to avoid multiple tabs
   // Initialize engine audio when flight begins
   initEngineAudio();
   // Show start banner
   showStartMessage();
}

function initEngineAudio(){
   try {
      if (!sfxCtx) sfxCtx = new (window.AudioContext||window.webkitAudioContext)();
      if (engine.initialized || !sfxCtx) return;
      const ctx = sfxCtx;
      const master = ctx.createGain();
      master.gain.value = 0.0;
      master.connect(ctx.destination);
      const v8Gain = ctx.createGain();
      v8Gain.gain.value = 1.0;
      v8Gain.connect(master);
      // V8 sequencer state
      const firingOrder = [1,5,4,8,6,3,7,2];
      const idleRpm = 1200;
         const maxRpmNoBoost = 3900; // cap without boost so boost clearly raises RPM
      const maxRpm = 10800;
      const pitchA = 160; // cylinders 1-4
      const pitchB = 120; // cylinders 5-8
      const clickDur = 0.055;
      engine = {
         initialized: true,
         master,
         v8Gain,
         firingOrder,
         seqIndex: 0,
            maxRpmNoBoost,
         nextEventTime: ctx.currentTime + 0.03,
         rpm: idleRpm,
         idleRpm,
         maxRpm,
         period: 15 / idleRpm, // seconds per fire; 4 fires/rev => 60/(rpm*4) == 15/rpm
         boostLevel: 0,        // smoothed 0..1 boost amount
         pitchA,
         pitchB,
         clickDur,
         lfoPhase: 0
      };
      // Build one persistent voice per cylinder
      engine.voices = [];
      for (let i=0;i<8;i++){
         const osc = ctx.createOscillator();
         osc.type = 'sine';
         const g = ctx.createGain();
         g.gain.value = 0.0;
         osc.connect(g).connect(v8Gain);
         // Slight per-cylinder detune for richness
         const det = (Math.random()*0.06 - 0.03); // ±3%
         const baseF = (i < 4 ? pitchA : pitchB) * (1 + det);
         osc.frequency.value = baseF;
         osc.start();
         engine.voices.push({ osc, gain: g, detune: det, last: 0 });
      }
      // Helper: trigger the cylinder's voice with a short envelope
      engine.playClick = (time, cylIndex)=>{
         try {
            const v = engine.voices[cylIndex|0];
            if (!v) return;
            const baseF = (cylIndex < 4 ? engine.pitchA : engine.pitchB) * (1 + (v.detune||0));
            v.osc.frequency.setValueAtTime(baseF, time);
            // envelope length based on time between same-cylinder firings
            const cycle = Math.max(0.01, 120 / Math.max(600, engine.rpm));
            const dur = Math.min(0.6 * cycle, 0.028);
            const att = Math.min(0.002, 0.25 * dur);
            const rpmNorm = Math.max(0, Math.min(1, (engine.rpm - engine.idleRpm) / Math.max(1, (engine.maxRpm - engine.idleRpm))));
            const midLift = Math.pow(Math.max(0, engineThrottle), 0.6); // stronger mid acceleration feel
            const dyn = Math.max(rpmNorm, midLift);
            const amp = 0.11 + 0.23 * dyn; // louder idle baseline
            const g = v.gain.gain;
            g.cancelScheduledValues(time);
            g.setValueAtTime(0.0001, time);
            g.linearRampToValueAtTime(amp, time + att);
            g.exponentialRampToValueAtTime(0.0001, time + dur);
            v.last = time;
         } catch(_){ }
      };
      // Ensure context is resumed on user gesture
      const unlock = ()=>{ if (ctx && typeof ctx.resume === 'function') ctx.resume(); window.removeEventListener('pointerdown', unlock); };
      window.addEventListener('pointerdown', unlock, { once: true });
   } catch(_){}}

function updateEngineAudio(dt){
   if (!engine.initialized) return;
   const ctx = sfxCtx;
   // 1) Compute a clean, linear motion scalar 0..1 from controls (no boost baked in)
   // Desktop: any movement keys pressed => 1, else 0. Mobile: joystick magnitude 0..1. Gamepad: left stick magnitude
   const hasKeyInput = (keys.w || keys.a || keys.s || keys.d || keys.q || keys.e) ? 1 : 0;
   const gamepad = window.GamepadController ? window.GamepadController.state : null;
   const gamepadConnected = gamepad && gamepad.connected;
   const mobileMag = (mobile && mobile.active && !gamepadConnected) ? Math.min(1, Math.hypot(mobile.move.x, mobile.move.y)) : 0;
   const gamepadMag = gamepadConnected ? Math.min(1, Math.hypot(gamepad.leftStick.x, gamepad.leftStick.y)) : 0;
   const motionScalar = Math.max(hasKeyInput, mobileMag, gamepadMag);

   // 2) Rate-limit throttle toward target using linear slew for consistency
   const upRate = 2.4;   // per second towards 1.0
   const downRate = 2.0; // per second towards 0.0
   engineThrottleTarget = motionScalar;
   const delta = engineThrottleTarget - engineThrottle;
   const maxStep = (delta > 0 ? upRate : downRate) * dt;
   if (Math.abs(delta) <= Math.abs(maxStep)) {
      engineThrottle = engineThrottleTarget;
   } else {
      engineThrottle += Math.sign(delta) * Math.abs(maxStep);
   }

   // 3) Smooth boost level and map throttle to RPM with boost headroom
   const boostTarget = (keys.shift || (gamepadConnected && gamepad.buttons.boost)) ? 1 : 0;
   const boostSlew = 4.0; // per second
   engine.boostLevel += (boostTarget - engine.boostLevel) * Math.min(1, boostSlew * dt);
   const baseMax = engine.maxRpmNoBoost || (engine.maxRpm - 800);
   // Capsule pickup overdrive: temporarily raise ceiling to 15000
   engine.pickupBoostTimer = Math.max(0, (engine.pickupBoostTimer||0) - dt);
   const overdriveMax = (engine.pickupBoostTimer > 0) ? 15000 : engine.maxRpm;
   // If pickup overdrive is active, allow ceiling to reach full overdriveMax independent of Shift boost
   const targetMax = (engine.pickupBoostTimer > 0)
      ? overdriveMax
      : Math.min(overdriveMax, baseMax + engine.boostLevel * Math.max(0, engine.maxRpm - baseMax));
   const targetRpm = engine.idleRpm + engineThrottle * (targetMax - engine.idleRpm);
   // 4) Slow, linear slew for RPM changes (slower increase as requested)
   const rpmSlewUp = (engine.pickupBoostTimer > 0) ? 7000 : 1500;   // faster surge during overdrive
   const rpmSlewDown = 2000; // RPM per second when decelerating
   const rpmDelta = targetRpm - engine.rpm;
   const rpmStep = (rpmDelta > 0 ? rpmSlewUp : rpmSlewDown) * dt;
   if (Math.abs(rpmDelta) <= Math.abs(rpmStep)) {
      engine.rpm = targetRpm;
   } else {
      engine.rpm += Math.sign(rpmDelta) * Math.abs(rpmStep);
   }
   // Clamp RPM to dynamic ceiling (overdrive raises this to 15000)
   engine.rpm = Math.max(400, Math.min(overdriveMax, engine.rpm));

   // 4) Master gain follows throttle linearly (light smoothing)
   const masterG = 0.18 + engineThrottle * 0.40 + (engine.pickupBoostTimer>0 ? 0.08 : 0.0); // slight gain lift during pickup
   engine.master.gain.setTargetAtTime(masterG, ctx.currentTime, 0.035);

   // 5) Smooth the period and schedule upcoming cylinder clicks with short lookahead
   const lookahead = 0.06; // seconds
   const measuredPeriod = 15 / Math.max(600, engine.rpm);
   // Smooth period toward measured to avoid small jitter at boundaries
   const periodSmooth = 1 - Math.exp(-dt * 10);
   engine.period += (measuredPeriod - engine.period) * periodSmooth;
   while (engine.nextEventTime < ctx.currentTime + lookahead) {
      const cyl = engine.firingOrder[engine.seqIndex];
      if (typeof engine.playClick === 'function') engine.playClick(engine.nextEventTime, (cyl - 1));
      engine.seqIndex = (engine.seqIndex + 1) % engine.firingOrder.length;
      engine.nextEventTime += engine.period;
   }
}

// Per-frame flight update
function updateFlight(dt){
   // Gamepad look input (right stick)
   const gamepadInstance = window.GamepadController ? window.GamepadController.state : null;
   if (gamepadInstance && gamepadInstance.connected) {
      const lookSpeed = gamepadInstance.sensitivity * 0.8; // radians per second at full deflection (reduced from 2.0)
      yawTarget -= gamepadInstance.rightStick.x * lookSpeed * dt;
      pitchTarget -= gamepadInstance.rightStick.y * lookSpeed * dt;
      pitchTarget = Math.max(-maxPitch, Math.min(maxPitch, pitchTarget));
   }

   // Smooth interpolation from current yaw/pitch to targets
   const smoothing = 12.0;
   yaw += (yawTarget - yaw) * Math.min(1, smoothing * dt);
   pitch += (pitchTarget - pitch) * Math.min(1, smoothing * dt);
   // Orientation from yaw/pitch targets
   const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
   camera.quaternion.copy(q);
   // Movement vectors
   const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(q);
   const right = new THREE.Vector3(1,0,0).applyQuaternion(q);
   const up = new THREE.Vector3(0,1,0).applyQuaternion(q);
   // Gradual acceleration: accelerate velocity toward desired input direction
   const baseSpeed = 60;
   const boostSpeed = 220;
   const pickupSpeed = (engine.pickupBoostTimer && engine.pickupBoostTimer>0) ? 1.6 : 1.0; // temporary speed multiplier

   // Check for boost input (keyboard shift or gamepad L2/LT)
   const boostActive = keys.shift || (gamepadInstance && gamepadInstance.connected && gamepadInstance.buttons.boost);
   const targetSpeed = (boostActive ? boostSpeed : baseSpeed) * pickupSpeed; // units/sec

   let wish = new THREE.Vector3();
   // Desktop keys
   if (keys.w) wish.add(fwd);
   if (keys.s) wish.sub(fwd);
   if (keys.a) wish.sub(right);
   if (keys.d) wish.add(right);
   // Q/E vertical translation (up/down)
   if (keys.q) wish.sub(up);
   if (keys.e) wish.add(up);

   // Gamepad left stick movement (overrides keyboard if active)
   if (gamepadInstance && gamepadInstance.connected) {
      const gMag = Math.hypot(gamepadInstance.leftStick.x, gamepadInstance.leftStick.y);
      if (gMag > 0.01) {
         const gRight = right.clone().multiplyScalar(gamepadInstance.leftStick.x);
         const gFwd = fwd.clone().multiplyScalar(-gamepadInstance.leftStick.y); // Invert Y for natural feel
         const gWish = gRight.add(gFwd);
         wish = gWish.normalize().multiplyScalar(targetSpeed * Math.min(1, gMag));
      }
   }

   // Mobile joystick (overrides horizontal plan motion, but not if gamepad is connected)
   const gamepadConnected = gamepadInstance && gamepadInstance.connected;
   if (mobile.active && !gamepadConnected) {
      const mag = Math.hypot(mobile.move.x, mobile.move.y);
      if (mag > 0.01) {
         const mRight = right.clone().multiplyScalar(mobile.move.x);
         const mFwd   = fwd.clone().multiplyScalar(mobile.move.y);
         wish = mRight.add(mFwd).normalize().multiplyScalar(targetSpeed * Math.min(1, mag));
      }
   }

   // Normalize keyboard input only if gamepad/mobile not active
   const gamepadActive = gamepadInstance && gamepadInstance.connected && Math.hypot(gamepadInstance.leftStick.x, gamepadInstance.leftStick.y) > 0.01;
   const mobileActive = mobile.active && !gamepadConnected;
   if (wish.lengthSq() > 0 && !mobileActive && !gamepadActive) {
      wish.normalize().multiplyScalar(targetSpeed);
   }
   const acc = boostActive ? 420 : 120; // stronger acceleration when boosting
   const toTarget = wish.clone().sub(playerVel);
   const maxDelta = acc * dt;
   if (toTarget.length() > maxDelta) {
      toTarget.setLength(maxDelta);
   }
   playerVel.add(toTarget);
   // Light drag to prevent infinite drift
   const drag = 0.06; // per second
   playerVel.multiplyScalar(Math.max(0, 1 - drag * dt));
   camera.position.addScaledVector(playerVel, dt);

   // Planet collisions: instant death (Earth and distant planets)
   if (earth) {
      const earthR = 20.0; // matches earth sphere
      const d = camera.position.distanceTo(earth.position);
      if (d < earthR + 0.1) {
         // Game over on impact
         setTimeout(()=>{ location.reload(); }, 100);
         return; // stop further updates this frame
      }
   }
   if (planets && planets.length) {
      for (const p of planets) {
         const r = (p && typeof p.radius === 'number') ? p.radius : 120;
         const d = camera.position.distanceTo(p.mesh.position);
         if (d < r + 1.0) { // small allowance for visual surface
            setTimeout(()=>{ location.reload(); }, 100);
            return;
         }
      }
   }

   // Update engine audio (idle vs thrust)
   // Throttle based on forward speed component relative to target speed
   const forwardSpeed = playerVel.dot(fwd);
   const forwardRatio = THREE.MathUtils.clamp(Math.abs(forwardSpeed) / Math.max(1, targetSpeed), 0, 1);
   const hasKeyInput = keys.w || keys.s || keys.a || keys.d || keys.q || keys.e;
   const mobileMag = Math.hypot(mobile.move.x, mobile.move.y);
   const hasMobileInput = mobile.active && !gamepadConnected && mobileMag > 0.05;
   const gamepadInput = (gamepadInstance && gamepadInstance.connected) ? Math.hypot(gamepadInstance.leftStick.x, gamepadInstance.leftStick.y) : 0;
   const hasGamepadInput = gamepadInput > 0.05;
   engineThrottleTarget = (hasKeyInput || hasMobileInput || hasGamepadInput) ? forwardRatio : 0.0;
   updateEngineAudio(dt);

   // Compute boost FX target (0..1) only when clearly boosting forward
   const isBoosting = boostActive && forwardRatio > 0.5;
   const boostTarget = boostActive ? THREE.MathUtils.clamp((forwardRatio - 0.5) / 0.5, 0, 1) : 0;
   const boostSmooth = 1 - Math.exp(-dt * 6);
   boostFx += (boostTarget - boostFx) * boostSmooth;
   // Keep Afterimage disabled entirely (we'll use vignette + FOV instead)
   if (afterimagePass) afterimagePass.enabled = false;
   // Apply boost FX to vignette and camera FOV
   if (vignettePass) vignettePass.uniforms.amount.value = boostFx * 0.5; // very subtle
   if (distortionPass) {
      // Base distortion from boost plus a short pulse spike
      const pulse = boostPulse;
      // Exponential decay of pulse
      boostPulse = Math.max(0, boostPulse - dt * 4.0);
      const amt = THREE.MathUtils.clamp(0.06 * boostFx + 0.10 * pulse, 0, 0.35);
      distortionPass.uniforms.amount.value = amt;
   }
   const baseFov = 60, maxKick = 6; // degrees
   const newFov = baseFov + boostFx * maxKick;
   if (Math.abs(camera.fov - newFov) > 0.01) { camera.fov = newFov; camera.updateProjectionMatrix(); }
   // Update boost state memory (kept for internal logic; SFX handled on key events)
   wasBoosting = isBoosting;

   // Keep player's ship attached to camera orientation/position
   if (playerShip) {
      // Smooth target-based sway and bank (gamepad > mobile > keyboard priority)
      const mobileInputActive = mobile.active && !gamepadConnected;
      let lr, fb;
      if (gamepadConnected && gamepadInstance) {
         // Use gamepad left stick
         lr = gamepadInstance.leftStick.x;
         fb = -gamepadInstance.leftStick.y; // Inverted Y
      } else if (mobileInputActive) {
         // Use mobile touch controls
         lr = mobile.move.x;
         fb = mobile.move.y;
      } else {
         // Use keyboard
         lr = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
         fb = (keys.w ? 1 : 0) - (keys.s ? 1 : 0);
      }
      const ud = (keys.e ? 1 : 0) - (keys.q ? 1 : 0);
      shipSwayTarget = lr * 1.2; // meters
      shipBankTarget = lr * THREE.MathUtils.degToRad(18); // roll degrees
      shipPitchLeanTarget = (fb + 0.6 * ud) * THREE.MathUtils.degToRad(6); // slight nose tilt plus up/down
      const damp = 1 - Math.exp(-dt * 10); // smoothing factor ~ critically damped
      shipSway += (shipSwayTarget - shipSway) * damp;
      shipBank += (shipBankTarget - shipBank) * damp;
      shipPitchLean += (shipPitchLeanTarget - shipPitchLean) * damp;

      // Compose ship orientation: camera orientation + roll (around forward) + slight pitch lean (around right)
      const qRoll = new THREE.Quaternion().setFromAxisAngle(fwd, shipBank);
      const qPitchLean = new THREE.Quaternion().setFromAxisAngle(right, -shipPitchLean);
      const shipQuat = q.clone().multiply(qRoll).multiply(qPitchLean);
      playerShip.quaternion.copy(shipQuat).multiply(PLAYER_YAW_LEFT);

      const shipOffset = 10.0; // meters in front of camera
      const downOffset = 1.2;  // place ship slightly below camera center
      playerShip.position.copy(camera.position)
         .add(fwd.clone().multiplyScalar(shipOffset))
         .add(right.clone().multiplyScalar(shipSway))
         .add(up.clone().multiplyScalar(-downOffset));

      // Update engine glows placement, flicker and scale based on thrust and boost
      const thrust = (keys.w ? 1.0 : 0.35) + (keys.shift ? 0.4 : 0);
      const boostScale = 1.0 + (boostFx || 0) * 1.0; // up to +100% size at full boost
      for (const s of engineGlows) {
         const flicker = 0.8 + Math.random() * 0.5; // keep some life
         const k = (1.0 + thrust * 0.6) * boostScale;
         const base = 0.35;
         const sx = base * k * flicker;
         const sy = base * k * 1.15 * flicker; // slightly taller for a flame look
         s.scale.set(sx, sy, 1);
         // Slightly brighter when boosting
         const baseOpacity = 0.5 + 0.25 * Math.random();
         s.material.opacity = Math.min(1.0, baseOpacity + (boostFx || 0) * 0.2);
      }
   }

   // Auto-fire while holding mobile, mouse, or gamepad fire
   const mobileFireActive = mobile.active && !gamepadConnected;
   if (mobileFireActive && mobile.firing) fireBullet();
   if (!mobileFireActive && mouseFiring) fireBullet();
   if (gamepadInstance && gamepadInstance.connected && gamepadInstance.buttons.fire) fireBullet();
}

function enemyShootFrom(ship){
   if (!ship || !ship.mesh || ship.active === false) return;
   // Aim at camera position
   const origin = ship.mesh.position.clone();
   const target = camera.position.clone();
   const dir = target.clone().sub(origin).normalize();
   const mesh = new THREE.Mesh(enemyBulletGeom, enemyBulletMat.clone());
   mesh.position.copy(origin.clone().add(dir.clone().multiplyScalar(2.5))); // start a bit away from ship
   scene.add(mesh);
   enemyBullets.push({ mesh, vel: dir.multiplyScalar(120), life: 6.0, maxLife: 6.0 });
}

function updateEnemiesFire(dt){
   // Hold off all enemy fire during the grace period
   if (typeof gameTime === 'number' && gameTime < enemyFireUnlockAt) return;
   for (const s of ships) {
      if (!s.ai || s.active === false) continue;
      s.ai.timer -= dt;
      if (s.ai.timer <= 0) {
         enemyShootFrom(s);
         // next cooldown with slight randomness
         s.ai.cooldown = Math.max(0.4, (s.ai.cooldown * 0.5 + (0.7 + Math.random() * 1.2) * 0.5));
         s.ai.timer = s.ai.cooldown;
      }
   }
}

function updateEnemyBullets(dt){
   const hitR = 2.4; // hit radius around the player (camera)
   for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      b.mesh.position.addScaledVector(b.vel, dt);
      b.life -= dt;
      // Fade slightly over life
      const t = Math.max(0, b.life / b.maxLife);
      b.mesh.material.opacity = 0.2 + 0.8 * t;
      // Hit test vs player
      const playerPos = camera.position; // treat camera as player center
      if (b.mesh.position.distanceTo(playerPos) < hitR) {
         // Damage player
         playerHealth = Math.max(0, playerHealth - 15);
         onPlayerDamaged(15);
         updateHealthbar(playerHealth);
         const hud = document.querySelector('.hud');
         if (hud) hud.textContent = `FLIGHT MODE — WASD move • Mouse aim • Click fire • Shift boost • F fullscreen — Score: ${score} | Health: ${playerHealth}`;
         // small explosion for hit
         spawnExplosion(b.mesh.position.clone());
         scene.remove(b.mesh);
         enemyBullets.splice(i, 1);
         if (playerHealth <= 0) {
            // Game over: reload the site
            setTimeout(()=>{ location.reload(); }, 200);
            return;
         }
         continue;
      }
      if (b.life <= 0) {
         scene.remove(b.mesh);
         enemyBullets.splice(i, 1);
      }
   }
}

function checkVictory(){
   if (!flightMode || victoryShown) return;
   // Victory when no active ships remain
   const anyActive = ships.some(s => s.active !== false);
   if (!anyActive) {
      victoryShown = true;
      const modal = document.getElementById('winModal');
      if (modal) {
         modal.style.display = '';
         const btn = document.getElementById('winOkBtn');
         if (btn) {
            btn.addEventListener('click', ()=>{ modal.style.display = 'none'; });
            // Enable Enter key
            if (typeof enableEnterKey === 'function') {
               enableEnterKey(modal, btn);
            }
         }
      }
   }
}

function fireBullet(){
   if (!flightMode) return;
   if (fireCooldown > 0) return;
   if (weaponOverheated) return; // Can't fire when overheated

   fireCooldown = 0.09; // ~11 rps

   // Increase heat when firing (reaches 1.0 after 5 seconds of continuous fire)
   // Fire rate is 1/0.09 = 11.11 shots/sec, so in 5 sec = 55.5 shots
   weaponHeat = Math.min(1.0, weaponHeat + (1.0 / 55.5));

   // Check if we just hit overheat threshold
   if (weaponHeat >= 1.0 && !weaponOverheated) {
      weaponOverheated = true;
      overheatCooldownTimer = 5.0;
      playSfx('explosion', 0.5); // Warning sound
   }

   playSfx('laser', 0.7);
   const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
   const muzzleOffset = 3.0;
   const start = (playerShip ? playerShip.position.clone() : camera.position.clone()).add(dir.clone().multiplyScalar(muzzleOffset));

   // Create bullet with color based on heat (blue -> yellow -> orange -> red)
   let bulletColor = 0x33b3ff; // default blue
   if (weaponHeat < 0.33) {
      // Cool: blue to cyan
      bulletColor = 0x33b3ff;
   } else if (weaponHeat < 0.66) {
      // Warm: cyan to yellow
      const t = (weaponHeat - 0.33) / 0.33;
      const r = Math.floor((0.2 + t * 0.8) * 255);
      const g = Math.floor((0.7 + t * 0.3) * 255);
      const b = Math.floor((1.0 - t * 0.6) * 255);
      bulletColor = (r << 16) | (g << 8) | b;
   } else {
      // Hot: yellow to red
      const t = (weaponHeat - 0.66) / 0.34;
      const r = 255;
      const g = Math.floor((1.0 - t * 0.6) * 255);
      const b = Math.floor((0.4 - t * 0.4) * 255);
      bulletColor = (r << 16) | (g << 8) | b;
   }

   const mat = new THREE.MeshBasicMaterial({
      color: bulletColor,
      transparent: true,
      opacity: 0.95,
      blending: THREE.AdditiveBlending,
      depthWrite: false
   });

   const mesh = new THREE.Mesh(bulletGeom, mat);
   mesh.position.copy(start);
   scene.add(mesh);
   bullets.push({ mesh, vel: dir.multiplyScalar(420), life: 2.2, maxLife: 2.2 });
   spawnFlash(start, 1.5, weaponHeat > 0.66 ? 0xffaa44 : 0xffff88);
}

function updateBullets(dt){
   fireCooldown = Math.max(0, fireCooldown - dt);

   // Handle weapon heat cooling and overheat recovery
   if (weaponOverheated) {
      overheatCooldownTimer -= dt;
      if (overheatCooldownTimer <= 0) {
         weaponOverheated = false;
         weaponHeat = 0;
      }
   } else {
      // Passive cooling when not firing (cools down in ~3 seconds)
      weaponHeat = Math.max(0, weaponHeat - dt * 0.33);
   }

   for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.mesh.position.addScaledVector(b.vel, dt);
      b.life -= dt;
      const t = Math.max(0, b.life / b.maxLife);
      b.mesh.material.opacity = 0.2 + 0.8 * t;
      // Collision with ships
      for (let j = ships.length - 1; j >= 0; j--) {
         const s = ships[j];
         const dist = b.mesh.position.distanceTo(s.mesh.position);
         const hitR = 3.0; // generous hit radius
         if (dist < hitR) {
            // Destroy ship and defer heavy cleanup to smooth frame time
            const shipMesh = s.mesh;
            const shipTrail = s.trailObj;
            scene.remove(shipMesh);
            if (shipTrail) scene.remove(shipTrail);
            cleanupQueue.push(()=>{
               try { shipMesh.geometry?.dispose?.(); } catch(_){}
               try {
                  if (Array.isArray(shipMesh.material)) shipMesh.material.forEach(m=>m?.dispose?.());
                  else shipMesh.material?.dispose?.();
               } catch(_){}
               if (shipTrail) {
                  try { shipTrail.geometry?.dispose?.(); } catch(_){}
                  try { shipTrail.material?.dispose?.(); } catch(_){}
               }
            });
            const defeatedPlanet = s.planetId;
            const explosionPos = s.mesh.position.clone();
            ships.splice(j, 1);
            spawnExplosion(explosionPos);
            spawnFlash(explosionPos, 6, 0xff6622);
            playSfx('explosion', 1.0);
            score += 1;
            const hud = document.querySelector('.hud');
            if (hud) hud.textContent = `FLIGHT MODE — WASD move • Mouse aim • Click fire • Shift boost • F fullscreen `;
            // Check if all saucers are now defeated
            const remainingShips = ships.filter(ship => ship.active !== false).length;
            if (remainingShips === 0) {
               showCuriosaModal('Victory! All saucers eliminated. We\'re working on a full-featured game with Apoc as the protagonist - coming in 2026!');
            }
            // If this ship belonged to a planet and all of that planet's enemies are gone, show curiosa
            if (defeatedPlanet) maybeShowCuriosa(defeatedPlanet);
            // Remove bullet on hit
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            break;
         }
      }
      // If bullet still exists, check collision with asteroids
      if (i < bullets.length) {
         for (let k = asteroids.length - 1; k >= 0; k--) {
            const a = asteroids[k];
            const ad = b.mesh.position.distanceTo(a.mesh.position);
            const aHitR = a.radius + 0.9; // allow some leeway
            if (ad < aHitR) {
               const explodePos = a.mesh.position.clone();
               spawnExplosion(explodePos);
               spawnFlash(explodePos, 7, 0xffaa66);
               playSfx('explosion', 0.8);
               // Fragment if large
               if (typeof breakAsteroid === 'function') breakAsteroid(a);
               // Remove asteroid
               scene.remove(a.mesh);
               try { a.mesh.geometry?.dispose?.(); } catch(_){}
               try { a.mesh.material?.dispose?.(); } catch(_){}
               asteroids.splice(k, 1);
               // Remove bullet
               scene.remove(b.mesh);
               bullets.splice(i, 1);
               break;
            }
         }
      }
      if (b.life <= 0) {
         scene.remove(b.mesh);
         bullets.splice(i, 1);
      }
   }
}

function spawnExplosion(pos){
   if (window.ExplosionSystem && typeof window.ExplosionSystem.spawn === 'function') {
      window.ExplosionSystem.spawn(pos);
      return;
   }
   try { if (typeof playSfx === 'function') playSfx('explosion', 0.75); } catch(_){ }
}

function updateExplosions(dt){
   if (window.ExplosionSystem && typeof window.ExplosionSystem.update === 'function') {
      window.ExplosionSystem.update(dt);
   }
}

function spawnFlash(pos, size = 8, color = 0xffaa44){
   if (!trailTexture) return;
   const mat = new THREE.SpriteMaterial({
      map: trailTexture,
      color: color,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: false
   });
   const sprite = new THREE.Sprite(mat);
   sprite.position.copy(pos);
   sprite.scale.set(size, size, 1);
   sprite.renderOrder = 1000; // draw late so it isn't hidden
   scene.add(sprite);
   flashes.push({ sprite, life: 0.15, maxLife: 0.15, startSize: size });
}

function updateFlashes(dt){
   for (let i = flashes.length - 1; i >= 0; i--){
      const f = flashes[i];
      f.life -= dt;
      const t = Math.max(0, f.life / f.maxLife);
      f.sprite.material.opacity = t;
      f.sprite.scale.set(f.startSize * (1 + (1 - t) * 0.5), f.startSize * (1 + (1 - t) * 0.5), 1);
      if (f.life <= 0){
         scene.remove(f.sprite);
         f.sprite.material.dispose();
         flashes.splice(i, 1);
      }
   }
}
</script>
<script>
// Ensure secret flight mode listeners are bound after definitions
(function(){
  if (typeof setupSecretFlightMode === 'function') setupSecretFlightMode();
})();
// SFX system is initialized after the first user gesture (see init()), to satisfy autoplay policies.
</script>
<!-- Hidden YouTube player container -->
<div id="yt-holder" aria-hidden="true"></div>
</body>
</html>
