<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
   <title>ArmaHeaven X195 — Earth + Orbits</title>
   <!-- Retro terminal font -->
   <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
     body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #000;
        font-family: Arial, sans-serif;
        color: #fff;
     }
     .overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 10;
     }
     h1 {
        font-size: 3em;
        margin: 0 0 20px 0;
        letter-spacing: 2px;
     }
     p {
        font-size: 1.2em;
        margin: 0 0 20px 0;
     }
     .links {
        margin-top: 20px;
     }
     .links a {
        display: inline-block;
        margin: 0 10px;
        padding: 10px 20px;
        border: 2px solid #fff;
        color: #fff;
        text-decoration: none;
        border-radius: 5px;
        transition: all 0.3s ease;
     }
     .links a:hover {
        background: #fff;
        color: #000;
     }
     /* Terminal style text: monospaced, glowing green, blinking caret */
     .terminal {
        font-family: 'VT323', SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        color: #00ff6a;
        text-shadow: 0 0 6px rgba(0,255,106,0.8), 0 0 18px rgba(0,255,106,0.5);
     }
     .terminal h1, .terminal p { color: inherit; text-shadow: inherit; }
     .caret {
        display: inline-block;
        margin-left: 6px;
        width: 0.6ch;
        color: #00ff6a;
        text-shadow: 0 0 10px rgba(0,255,106,0.9), 0 0 24px rgba(0,255,106,0.6);
        animation: blink 1s steps(1, end) infinite;
     }
     @keyframes blink {
        0%, 49% { opacity: 1; }
        50%, 100% { opacity: 0; }
     }
     /* Make the links fit the green terminal theme */
     .links a {
        border-color: #00ff6a;
        color: #00ff6a;
        text-shadow: 0 0 6px rgba(0,255,106,0.8);
     }
     .links a:hover {
        background: #00ff6a;
        color: #000;
        box-shadow: 0 0 12px rgba(0,255,106,0.8), 0 0 30px rgba(0,255,106,0.5);
     }
   /* Make the logo pop over a dark scene: use screen blend and a soft glow */
   .logo {
      mix-blend-mode: screen; /* brightens over dark backgrounds; keeps white transparent areas subtle */
      filter: drop-shadow(0 0 12px rgba(255,255,255,0.6));
   }
   /* Fixed logo in upper-left corner */
   .logo-fixed {
      position: fixed;
      top: 12px;
      left: 12px;
      width: 120px;
      height: auto;
      z-index: 30;
      pointer-events: auto;
      cursor: pointer;
      transition: transform 0.15s ease, filter 0.15s ease;
   }
   .logo-fixed:hover {
      transform: scale(1.04);
      filter: drop-shadow(0 0 16px rgba(255,255,255,0.85));
   }
   /* Bottom-right icon links */
   .corner-links {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 12;
      display: flex;
      gap: 12px;
      align-items: center;
   }
   .corner-links a {
      display: inline-flex;
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: rgba(255,255,255,0.06);
      backdrop-filter: blur(2px);
      justify-content: center;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.12);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
   }
   .corner-links a:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 14px rgba(51,179,255,0.85), 0 0 32px rgba(51,179,255,0.55);
      background: rgba(51,179,255,0.15);
      border-color: rgba(51,179,255,0.7);
    }
   .corner-links svg { width: 22px; height: 22px; }
   .corner-links .spotify { fill: #1ED760; }
   .corner-links .patreon { fill: #FF424D; }
   .corner-links a:hover .spotify, .corner-links a:hover .patreon { fill: #33b3ff; }

   /* Darkening overlay under text */
   .shade {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      z-index: 5; /* below overlay (10), above canvas */
      pointer-events: none;
   }
    /* Intro modal */
    .modal-backdrop {
         position: fixed;
         inset: 0;
         background: rgba(0,0,0,0.7);
         display: flex;
         align-items: center;
         justify-content: center;
         z-index: 40;
      }
      .modal-card {
         background: rgba(10,10,14,0.85);
         border: 1px solid rgba(51,179,255,0.4);
         border-radius: 12px;
         padding: 22px 26px;
         width: min(92vw, 560px);
         box-shadow: 0 0 26px rgba(51,179,255,0.5), 0 0 60px rgba(26,120,190,0.35);
         text-align: center;
         backdrop-filter: blur(6px);
      }
      .modal-card h2 {
         font-family: 'VT323', monospace;
         font-size: 40px;
         margin: 0 0 8px 0;
         color: #33b3ff;
         text-shadow: 0 0 10px rgba(51,179,255,0.9);
      }
      .modal-card p {
         font-family: 'VT323', monospace;
         font-size: 22px;
         color: #9fd9ff;
         margin: 0 0 18px 0;
      }
      .modal-actions button {
         font-family: 'VT323', monospace;
         font-size: 18px;
         padding: 10px 16px;
         color: #cfeeff;
         background: rgba(51,179,255,0.12);
         border: 1px solid rgba(51,179,255,0.6);
         border-radius: 8px;
         cursor: pointer;
         text-shadow: 0 0 10px rgba(51,179,255,0.8);
         box-shadow: 0 0 12px rgba(51,179,255,0.5);
      }
      .modal-actions button:hover {
         box-shadow: 0 0 18px rgba(51,179,255,0.9), 0 0 38px rgba(51,179,255,0.6);
         color: #e9f7ff;
         background: rgba(51,179,255,0.2);
      }
   /* Simple audio player widget */
   .audio-widget {
      position: fixed;
      left: 12px;
      bottom: 56px; /* sit above the HUD */
      z-index: 22;
      display: flex;
      gap: 10px;
      align-items: center;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 8px 10px;
      backdrop-filter: blur(3px);
   }
   .audio-widget button {
      font-family: 'VT323', monospace;
      font-size: 16px;
      padding: 6px 10px;
      color: #00ff6a;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(0,255,106,0.5);
      border-radius: 6px;
      text-shadow: 0 0 6px rgba(0,255,106,0.8);
      cursor: pointer;
   }
   .audio-widget button:hover { box-shadow: 0 0 14px rgba(51,179,255,0.85), 0 0 32px rgba(51,179,255,0.55); color: #66ccff; border-color: rgba(102,204,255,0.8); }
   .audio-widget a {
      color: #1ED760;
      text-decoration: none;
      font-family: 'VT323', monospace;
      font-size: 16px;
      border-bottom: 1px dashed rgba(30,215,96,0.6);
   }
   .audio-widget a:hover { color: #6ff0a3; }
       .hud {
            position: absolute;
            left: 12px;
            bottom: 12px;
            opacity: 0.7;
            font-size: 12px;
            z-index: 10;
       }
     /* Healthbar */
     .healthbar { position: fixed; top: 12px; left: 12px; width: 220px; height: 18px; border: 1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.35); backdrop-filter: blur(4px); z-index: 30; display: none; }
     .healthbar .fill { height: 100%; width: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); box-shadow: 0 0 12px rgba(46,204,113,0.7) inset; transition: width 120ms ease-out; }
     .healthbar.low .fill { background: linear-gradient(90deg, #ff6b6b, #e74c3c); box-shadow: 0 0 12px rgba(255,107,107,0.7) inset; }
     .healthbar .label { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; font-family: 'VT323', monospace; font-size: 14px; text-shadow: 0 0 6px rgba(0,0,0,0.6); }
   /* Damage flash overlay */
   #damageFlash { position: fixed; inset: 0; pointer-events: none; z-index: 40; background: rgba(255,30,20,0); mix-blend-mode: screen; }
  /* Mobile controls overlay */
  .mobile-controls { position: fixed; inset: 0; z-index: 25; pointer-events: none; }
  .mobile-controls .pad {
     position: absolute; bottom: 16px; left: 16px;
     width: min(34vw, 180px); height: min(34vw, 180px);
     border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
     background: rgba(255,255,255,0.05);
     backdrop-filter: blur(4px);
     pointer-events: auto;
     touch-action: none;
  }
  .mobile-controls .stick {
     position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
     width: 40%; height: 40%; border-radius: 50%;
     background: radial-gradient(circle, rgba(51,179,255,0.9), rgba(51,179,255,0.3));
     border: 1px solid rgba(51,179,255,0.7);
  }
  .mobile-controls .fire {
     position: absolute; right: 16px; bottom: 16px;
     width: min(22vw, 120px); height: min(22vw, 120px);
     border-radius: 50%;
     background: radial-gradient(circle, rgba(255,80,80,0.9), rgba(255,80,80,0.25));
     border: 1px solid rgba(255,120,120,0.7);
     box-shadow: 0 0 18px rgba(255,80,80,0.7);
     pointer-events: auto;
     touch-action: manipulation;
   }
  .mobile-controls .fire:active { transform: scale(0.96); }
   /* Hide mobile controls when aria-hidden is true */
   .mobile-controls[aria-hidden="true"] { display: none; }

  /* Responsive tweaks */
  @media (max-width: 820px), (pointer: coarse) {
     .logo-fixed { width: 84px; }
     .corner-links { right: 8px; bottom: 8px; }
     .corner-links a { width: 36px; height: 36px; }
     .terminal h1 { font-size: 9.5vw; }
     .terminal p { font-size: 4.4vw; }
     .audio-widget { display: none; }
     .hud { font-size: 13px; }
  }
  /* Hidden YouTube holder for background audio */
  #yt-holder {
   position: fixed;
   width: 1px;
   height: 1px;
   left: -10000px;
   top: auto;
   opacity: 0;
   pointer-events: none;
   z-index: -1;
  }
  </style>
</head>
<body>
<div id="container"></div>
<div class="shade"></div>
<!-- HUD for score/health -->
<div class="hud"></div>
<!-- Healthbar -->
<div id="healthbar" class="healthbar" aria-hidden="true"><div class="fill"></div><div class="label">100</div></div>
<div id="damageFlash" aria-hidden="true"></div>
<!-- Intro modal -->
<div id="readyModal" class="modal-backdrop">
   <div class="modal-card">
      <h2>Are you ready?</h2>
      <p>Headphones on. Neony engaged. Let’s go.</p>
      <div class="modal-actions">
         <button id="readyBtn">Enter</button>
      </div>
   </div>
  
</div>
<!-- Victory modal -->
<div id="winModal" class="modal-backdrop" style="display:none">
   <div class="modal-card">
      <h2>Mission Complete</h2>
      <p>SMASH INTO PIECES is actively working on a video game to be released in 2026.<br/>More news coming soon.</p>
      <div class="modal-actions">
         <button id="winOkBtn">OK</button>
      </div>
   </div>
</div>
<!-- Fixed logo in top-left -->
<img class="logo logo-fixed" src="./apoc-sip-symbol.png" alt="Apoc Logo">
<div class="overlay">
    <div class="terminal">
      <h1>ArmaHeaven X195</h1>
   <p>Are you prepared for what's coming? Can you see into the future?<span class="caret">▌</span></p>
    </div>
</div>
<!-- Mobile controls (shown on touch devices) -->
<div class="mobile-controls" aria-hidden="true">
   <div class="pad" id="joyLeft">
       <div class="stick" id="joyStick"></div>
   </div>
   <button class="fire" id="fireBtn" aria-label="Fire"></button>
</div>

<!-- Bottom-right icon links -->
<div class="corner-links">
  <a href="https://open.spotify.com/artist/2vhrwzjf9H3icunkVFi9tq?" target="_blank" aria-label="Spotify">
    <svg class="spotify" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img">
      <path d="M12 0C5.372 0 0 5.373 0 12c0 6.628 5.372 12 12 12s12-5.372 12-12C24 5.373 18.628 0 12 0zm5.484 17.28a.752.752 0 0 1-1.036.246c-2.839-1.736-6.42-2.13-10.62-1.172a.75.75 0 1 1-.33-1.462c4.56-1.032 8.5-.583 11.61 1.29.357.218.47.684.246 1.098zm1.375-3.08a.94.94 0 0 1-1.298.307c-3.25-1.99-8.206-2.57-12.056-1.418a.94.94 0 1 1-.536-1.806c4.32-1.28 9.77-.64 13.4 1.55a.94.94 0 0 1 .49 1.366zm.13-3.235a1.126 1.126 0 0 1-1.556.368c-3.72-2.27-9.39-2.48-12.753-1.382a1.125 1.125 0 0 1-.67-2.152c3.89-1.213 10.21-1.003 14.48 1.586.52.317.69 1 .5 1.58z"/>
    </svg>
  </a>
  <a href="https://www.patreon.com/smashheads" target="_blank" aria-label="Patreon">
    <svg class="patreon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img">
      <path d="M1.5 2h3v20h-3V2zm13 0A8.5 8.5 0 0 1 23 10.5c0 4.694-3.806 8.5-8.5 8.5H12V2h2.5z"/>
    </svg>
  </a>
</div>
<!-- YouTube IFrame API for background music -->
<script src="https://www.youtube.com/iframe_api"></script>
<!-- Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- GLTFLoader for ship model -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<!-- Postprocessing for glow/bloom (r128-compatible) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<!-- Lens flare for the Sun -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Lensflare.js"></script>
<!-- Subtle motion blur (Afterimage) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/AfterimageShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/AfterimagePass.js"></script>
<!-- Motion blur removed -->
<script>
let scene, camera, renderer, stars;
let earth, ships = [], clock;
let cleanupQueue = [];
let composer, bloomPass, afterimagePass, vignettePass, beam, redLight;
let sunLight = null, sunCore = null, sunGlow = null;
let shipGLTF = null;
let trailTexture = null;
let cameraOrbit = null; // { radius, theta, speed, height }
let playerShip = null; // player's ship spawned in flight mode
let engineGlows = []; // sprites for engine flames
let playerTrail = null; // player's trail { len, geom, positions, colors, points }
let planets = []; // distant planets with enemies
// Speed lines effect state
let speedLines = { group: null, sprites: [], texture: null, active: false };
const curiosa = {
   p1: 'Per is great at imitating gunde svan',
   p2: 'Adam is a big blizzard fan',
   p3: 'Benjamin is a great musician',
   p4: 'Apoc plays all instruments known to mankind'
};
// Smooth flight feel state
let shipSway = 0, shipSwayTarget = 0;           // lateral offset (meters)
let shipBank = 0, shipBankTarget = 0;           // roll around forward (radians)
let shipPitchLean = 0, shipPitchLeanTarget = 0; // slight nose tilt with accel (radians)
let playerVel = new THREE.Vector3();            // player velocity (world units/sec)
// Damage FX state
let damageFlashEl = null, damageFlashAlpha = 0;
let shakeTime = 0, shakeDuration = 0.25, shakeMagnitude = 0;
// Boost FX state (non-blur): FOV kick + vignette
let boostFx = 0, boostFxTarget = 0, wasBoosting = false;
// Mobile controls state
let mobile = {
   active: false,                // true on touch devices
   move: { x: 0, y: 0 },         // left stick normalized [-1,1]
   lookDelta: { x: 0, y: 0 },    // accumulated look deltas (pixels) since last frame
   firing: false,                // fire button held
   touching: false, id: null,    // joystick pointer tracking
   center: { x: 0, y: 0 }, radius: 80,
   stickEl: null, padEl: null, fireBtn: null,
   lookId: null, prevLook: { x: 0, y: 0 }
};
const Y_AXIS = new THREE.Vector3(0, 1, 0);
// Player-specific yaw offset (rotate a bit further to the left)
const PLAYER_YAW_LEFT = new THREE.Quaternion().setFromAxisAngle(Y_AXIS, -THREE.MathUtils.degToRad(0));
// Enemy ships need an additional left yaw to align their noses with motion
const ENEMY_YAW_LEFT = new THREE.Quaternion().setFromAxisAngle(Y_AXIS, THREE.MathUtils.degToRad(45));

// Secret flight mode
let flightMode = false;
let yaw = 0, pitch = 0;          // smoothed orientation
let yawTarget = 0, pitchTarget = 0; // target orientation (mouse input)
const maxPitch = Math.PI / 2 - 0.05;
const keys = { w:false, a:false, s:false, d:false, q:false, e:false, shift:false };
let bullets = [];
let explosions = [];
let enemyBullets = [];
let lastTime = 0;
let fireCooldown = 0;
let score = 0;
let bulletGeom, bulletMat;
let enemyBulletGeom, enemyBulletMat;
let playerHealth = 100;
let victoryShown = false;
let gameTime = 0;
// SFX buffers
let sfxCtx = null;
const sfx = { click: null, laser: null, explosion: null, boost: null, boostRev: null };
let lastBoostSfxTime = 0; // seconds, to debounce boost trigger sound
let lastBoostReleaseSfxTime = 0; // debounce for release whoosh
// Engine loop audio
let engine = { initialized:false, master:null, baseOsc:null, baseGain:null, overtoneOsc:null, overtoneGain:null };
let engineThrottle = 0, engineThrottleTarget = 0;

// Model URL (place your file at this path or change the URL to match your asset)
const SHIP_MODEL_URL = './3d/ship.glb';

function setupMobileControls(){
   // Detect touch/coarse pointer devices
   const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || window.matchMedia('(pointer: coarse)').matches;
   mobile.active = !!isTouch;
   const controls = document.querySelector('.mobile-controls');
   if (!controls) return;
   if (!isTouch) {
      // Keep hidden on desktops
      controls.setAttribute('aria-hidden', 'true');
      return;
   }
   controls.setAttribute('aria-hidden', 'false');

   // Cache elements
   mobile.padEl = document.getElementById('joyLeft');
   mobile.stickEl = document.getElementById('joyStick');
   mobile.fireBtn = document.getElementById('fireBtn');
   const canvas = document.getElementById('container');

   // Helper to clamp stick and update mobile.move
   function updateStick(clientX, clientY){
      const r = mobile.padEl.getBoundingClientRect();
      // Center of pad
      const cx = r.left + r.width * 0.5;
      const cy = r.top + r.height * 0.5;
      mobile.center.x = cx; mobile.center.y = cy;
      const maxR = Math.min(r.width, r.height) * 0.5 * 0.85;
      let dx = clientX - cx;
      let dy = clientY - cy;
      const len = Math.hypot(dx, dy) || 1;
      const cl = Math.min(len, maxR);
      dx = dx / len * cl;
      dy = dy / len * cl;
      // Position visual stick
      if (mobile.stickEl) {
         mobile.stickEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      }
      // Normalize to [-1,1]; invert Y so up = forward
      mobile.move.x = dx / maxR;
      mobile.move.y = -dy / maxR;
   }

   // Left pad pointer handlers
   function onJoyDown(e){
      e.preventDefault();
      mobile.touching = true; mobile.id = e.pointerId || 'p';
      updateStick(e.clientX, e.clientY);
   }
   function onJoyMove(e){
      if (!mobile.touching) return;
      if ((e.pointerId || 'p') !== mobile.id) return;
      e.preventDefault();
      updateStick(e.clientX, e.clientY);
   }
   function onJoyUp(e){
      if ((e.pointerId || 'p') !== mobile.id) return;
      e.preventDefault();
      mobile.touching = false; mobile.id = null;
      mobile.move.x = 0; mobile.move.y = 0;
      if (mobile.stickEl) mobile.stickEl.style.transform = 'translate(-50%, -50%)';
   }
   if (mobile.padEl) {
      mobile.padEl.addEventListener('pointerdown', onJoyDown, { passive: false });
      window.addEventListener('pointermove', onJoyMove, { passive: false });
      window.addEventListener('pointerup', onJoyUp, { passive: false });
      window.addEventListener('pointercancel', onJoyUp, { passive: false });
   }

   // Fire button
   if (mobile.fireBtn) {
      mobile.fireBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); mobile.firing = true; fireBullet(); }, { passive: false });
      const stopFire = (e)=>{ if (e) e.preventDefault(); mobile.firing = false; };
      mobile.fireBtn.addEventListener('pointerup', stopFire, { passive: false });
      mobile.fireBtn.addEventListener('pointercancel', stopFire, { passive: false });
      mobile.fireBtn.addEventListener('pointerleave', stopFire, { passive: false });
   }

   // Look swipe on the canvas (right side of screen or anywhere not on controls)
   function isControlElement(el){
      if (!el) return false;
      return el.closest && el.closest('.mobile-controls');
   }
   function onLookDown(e){
      // Ignore if starting on a control element
      if (isControlElement(e.target)) return;
      e.preventDefault();
      mobile.lookId = e.pointerId || 'l';
      mobile.prevLook.x = e.clientX; mobile.prevLook.y = e.clientY;
   }
   function onLookMove(e){
      if ((e.pointerId || 'l') !== mobile.lookId) return;
      e.preventDefault();
      const dx = e.clientX - mobile.prevLook.x;
      const dy = e.clientY - mobile.prevLook.y;
      mobile.prevLook.x = e.clientX; mobile.prevLook.y = e.clientY;
      // accumulate deltas; consumed each frame in updateFlight
      mobile.lookDelta.x += dx;
      mobile.lookDelta.y += dy;
   }
   function onLookUp(e){
      if ((e.pointerId || 'l') !== mobile.lookId) return;
      e.preventDefault();
      mobile.lookId = null;
   }
   if (canvas) {
      canvas.addEventListener('pointerdown', onLookDown, { passive: false });
      window.addEventListener('pointermove', onLookMove, { passive: false });
      window.addEventListener('pointerup', onLookUp, { passive: false });
      window.addEventListener('pointercancel', onLookUp, { passive: false });
   }
}

function init() {
   scene = new THREE.Scene();

   // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
   camera.position.set(0, 30, 120);
   // Set up a slow orbit around the Earth (around Y axis) for non-flight mode
   const rXZ = Math.hypot(camera.position.x, camera.position.z);
   const theta0 = Math.atan2(camera.position.z, camera.position.x);
   cameraOrbit = { radius: rXZ, theta: theta0, speed: 0.02, height: camera.position.y };
   // Slight diagonal tilt (incline orbit plane a bit around X)
   cameraOrbit.tilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(12));

   // Renderer
   renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Better color management for textures
      renderer.outputEncoding = THREE.sRGBEncoding;
   renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
   document.getElementById('container').appendChild(renderer.domElement);
   // Setup mobile controls after DOM available
   setupMobileControls();

   // No orbit controls per request (camera is static)

   // Lights: ambient + sun + rim + hemisphere for "epic" contrast
      scene.add(new THREE.AmbientLight(0x303030, 0.5));
      const sun = new THREE.DirectionalLight(0xffffff, 1.6);
      sun.position.set(120, 60, 80);
      scene.add(sun);

      const rim = new THREE.DirectionalLight(0xfff0e0, 0.6);
      rim.position.set(-80, -30, -70);
      scene.add(rim);

      const hemi = new THREE.HemisphereLight(0x445566, 0x000011, 0.4);
      scene.add(hemi);

   // Distant Sun with lens flare and point light
   createSun();

   // Trail texture for ship glow
   trailTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png');
      // Bullet shared resources
      bulletGeom = new THREE.SphereGeometry(0.3, 8, 8);
      bulletMat = new THREE.MeshBasicMaterial({ color: 0x33b3ff, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false });
      // Enemy bullet resources
      enemyBulletGeom = new THREE.SphereGeometry(0.28, 8, 8);
      enemyBulletMat = new THREE.MeshBasicMaterial({ color: 0xff5533, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false });

   // Starfield background
   const starGeometry = new THREE.BufferGeometry();
      const starCount = 15000; // denser starfield
   const positions = new Float32Array(starCount * 3);
   for (let i = 0; i < starCount; i++) {
         const r = 2000 + Math.random() * 7000; // 2,000 .. 9,000 (within camera far 10,000)
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);
   }
   starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
   stars = new THREE.Points(starGeometry, starMaterial);
   scene.add(stars);

   // Create distant planets with lurking enemies
   createDistantPlanets();

      // Earth: higher-res diffuse + specular maps; red emissive glow
   const texLoader = new THREE.TextureLoader();
   const diffuseTex = texLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
   const specularTex = texLoader.load('./3d/earth_specular.png');
      // sRGB for albedo/diffuse
      diffuseTex.encoding = THREE.sRGBEncoding;
   // Ensure equirectangular (2:1) maps 1:1 across sphere
   diffuseTex.wrapS = THREE.RepeatWrapping;
   specularTex.wrapS = THREE.RepeatWrapping;
   diffuseTex.repeat.set(1, 1);
   specularTex.repeat.set(1, 1);
   diffuseTex.offset.set(0, 0);
   specularTex.offset.set(0, 0);
   // Improve texture sharpness
   const maxAniso = renderer.capabilities.getMaxAnisotropy();
   diffuseTex.anisotropy = maxAniso;
   specularTex.anisotropy = maxAniso;
   // Optional longitudinal rotation (degrees) if you need to re-center continents
   const EARTH_LON_OFFSET_DEG = 0; // tweak if alignment is off
   const lonOffset = THREE.MathUtils.degToRad(EARTH_LON_OFFSET_DEG);
   [diffuseTex, specularTex].forEach(t => { t.center.set(0.5, 0.5); t.rotation = lonOffset; });

      const earthGeo = new THREE.SphereGeometry(20, 256, 128);
      const earthMat = new THREE.MeshPhongMaterial({
         map: diffuseTex,
         specularMap: specularTex,
         specular: new THREE.Color(0x333333),
         shininess: 35,
         emissive: new THREE.Color(0xff2030), // red glow
         emissiveMap: specularTex, // oceans/city lights drive emissive
         emissiveIntensity: 0.6
      });
      earth = new THREE.Mesh(earthGeo, earthMat);
      scene.add(earth);

         // Atmosphere: gradient rim glow via Fresnel-style shader (smooth, "blurred" halo)
            const atmoGeo = new THREE.SphereGeometry(20.75, 192, 96); // slightly larger, subtle halo
         const atmoMat = new THREE.ShaderMaterial({
             uniforms: {
                color: { value: new THREE.Color(0xff3030) },
                   intensity: { value: 1.0 },  // stronger red halo
                   power: { value: 2.6 }       // softer rim
             },
             vertexShader: `
                varying vec3 vWorldPosition;
                varying vec3 vWorldNormal;
                void main(){
                   vec4 wp = modelMatrix * vec4(position, 1.0);
                   vWorldPosition = wp.xyz;
                   // Transform normal to world space
                   vWorldNormal = normalize(mat3(modelMatrix) * normal);
                   gl_Position = projectionMatrix * viewMatrix * wp;
                }
             `,
             fragmentShader: `
                uniform vec3 color;
                uniform float intensity;
                uniform float power;
                varying vec3 vWorldPosition;
                varying vec3 vWorldNormal;
                void main(){
                   // View direction in world space
                   vec3 V = normalize(cameraPosition - vWorldPosition);
                   // Rim factor (Fresnel). BackSide mesh gives outward normals; use abs for robustness
                   float rim = 1.0 - max(0.0, dot(normalize(vWorldNormal), V));
                   rim = pow(rim, power);
                   // Color and alpha follow the rim for a soft gradient
                   vec3 glow = color * rim * intensity;
                   float alpha = rim * 0.85 * (intensity * 0.9);
                   gl_FragColor = vec4(glow, alpha);
                }
             `,
             transparent: true,
             blending: THREE.AdditiveBlending,
             depthWrite: false,
             side: THREE.BackSide
         });
         const atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
         earth.add(atmosphere);

      // Red beam: a very tall additive cylinder starting at Earth's north pole shooting along +Y
      const beamHeight = 4000;
   // Thinner beam (narrow radii). Top/bottom radii kept slightly different for a subtle taper.
   const beamGeom = new THREE.CylinderGeometry(0.6, 1.2, beamHeight, 48, 1, true);
      const beamMat = new THREE.MeshBasicMaterial({
         color: 0xff2030,
         transparent: true,
         opacity: 0.45,
         blending: THREE.AdditiveBlending,
         depthWrite: false,
         side: THREE.DoubleSide
      });
      beam = new THREE.Mesh(beamGeom, beamMat);
      // position so the bottom sits at y = earthRadius (north pole)
      beam.position.set(0, 20 + beamHeight / 2, 0);
      scene.add(beam);

      // Red point light near the beam base to add local glow on Earth
      redLight = new THREE.PointLight(0xff2030, 2.2, 600, 2);
      redLight.position.set(0, 30, 0);
      scene.add(redLight);

      // Load ship model then create ships on random orbits
   loadShipModel().then(() => createShips(12));

      // Postprocessing composer with bloom for glow
   composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.6, 0.12);
      composer.addPass(bloomPass);
      // Extremely subtle boost-only motion blur (disabled by default)
      afterimagePass = new THREE.AfterimagePass(0.9998);
      afterimagePass.enabled = false;
      composer.addPass(afterimagePass);
   // Vignette pass for boost effect (starts disabled with amount 0)
   vignettePass = createVignettePass();
   composer.addPass(vignettePass);
         // Speed lines overlay for boost sensation
         createSpeedLines();

      // Timing
   clock = new THREE.Clock();

   // Events
   window.addEventListener('resize', onWindowResize, false);

   animate();

   // Secret tap-to-unlock flight mode (tap title 5x)
   if (typeof setupSecretFlightMode === 'function') setupSecretFlightMode();
   // Prepare SFX system
   if (typeof setupSfx === 'function') setupSfx();
   // Prepare damage FX overlay
   setupDamageFx();
}

async function loadShipModel() {
   return new Promise((resolve) => {
      const loader = new THREE.GLTFLoader();
      loader.load(
         SHIP_MODEL_URL,
         (gltf) => {
            shipGLTF = gltf.scene;
            // Rotate model so its nose points along -Z (Three.js lookAt aligns -Z toward target)
            shipGLTF.rotation.y = -Math.PI / 2;
            // Ensure PBR materials look right
            shipGLTF.traverse((obj) => {
               if (obj.isMesh && obj.material) {
                  if (obj.material.map) obj.material.map.encoding = THREE.sRGBEncoding;
                  obj.material.needsUpdate = true;
               }
            });
            resolve();
         },
         undefined,
         (err) => {
            console.warn('Ship model failed to load at', SHIP_MODEL_URL, err);
            shipGLTF = null; // fallback will use procedural box
            resolve();
         }
      );
   });
}

// Simple vignette shader pass for boost effect
function createVignettePass(){
   const VignetteShader = {
      uniforms: {
         tDiffuse: { value: null },
         amount: { value: 0.0 }, // 0..1
      },
      vertexShader: `
         varying vec2 vUv;
         void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
      fragmentShader: `
         uniform sampler2D tDiffuse;
         uniform float amount;
         varying vec2 vUv;
         void main(){
            vec4 col = texture2D(tDiffuse, vUv);
            // radial factor from center
            vec2 p = vUv * 2.0 - 1.0;
            float r = clamp(length(p), 0.0, 1.0);
            // ease curve for soft edges
            float vig = smoothstep(0.7, 1.0, r);
            // darken edges slightly and add a tiny warm tint on boost
            float dark = mix(1.0, 0.92, amount * vig);
            vec3 tint = mix(col.rgb, col.rgb * vec3(1.02, 0.98, 0.95), amount * vig * 0.6);
            gl_FragColor = vec4(tint * dark, col.a);
         }
      `
   };
   const pass = new THREE.ShaderPass(VignetteShader);
   pass.renderToScreen = false;
   return pass;
}

// Speed lines (boost effect): a pool of camera-facing streak sprites spawned ahead of the camera
function createSpeedLines(){
   // Generate a vertical streak texture (white core fading to transparent)
   const size = { w: 16, h: 128 };
   const canvas = document.createElement('canvas');
   canvas.width = size.w; canvas.height = size.h;
   const ctx = canvas.getContext('2d');
   const grad = ctx.createLinearGradient(0, 0, 0, size.h);
   grad.addColorStop(0.00, 'rgba(255,255,255,0.0)');
   grad.addColorStop(0.15, 'rgba(255,255,255,0.3)');
   grad.addColorStop(0.50, 'rgba(255,255,255,0.9)');
   grad.addColorStop(0.85, 'rgba(255,255,255,0.3)');
   grad.addColorStop(1.00, 'rgba(255,255,255,0.0)');
   ctx.fillStyle = grad;
   ctx.fillRect(0, 0, size.w, size.h);
   const streakTex = new THREE.CanvasTexture(canvas);
   streakTex.minFilter = THREE.LinearFilter;
   streakTex.magFilter = THREE.LinearFilter;
   streakTex.wrapS = THREE.ClampToEdgeWrapping;
   streakTex.wrapT = THREE.ClampToEdgeWrapping;
   speedLines.texture = streakTex;

   const material = new THREE.SpriteMaterial({
      map: streakTex,
      color: 0x99ccff,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: false,
      opacity: 0.0
   });
   const group = new THREE.Group();
   group.renderOrder = 999; // draw late
   scene.add(group);
   speedLines.group = group;
   const COUNT = 90;
   for (let i=0;i<COUNT;i++){
      const sp = new THREE.Sprite(material.clone());
      sp.scale.set(0.06, 3.0, 1);
      sp.visible = false;
      // Rotate 90 degrees so streaks are horizontal on screen
      sp.material.rotation = Math.PI * 0.5;
      group.add(sp);
      speedLines.sprites.push({ sprite: sp, vel: 0, life: 0, maxLife: 1 });
   }
}

function updateSpeedLines(dt){
   if (!speedLines.group) return;
   // Determine activation from boostFx (global)
   const active = boostFx > 0.05;
   speedLines.active = active;
   speedLines.group.visible = active;
   if (!active) {
      // fade out smoothly
      for (const s of speedLines.sprites) {
         if (s.sprite.material.opacity > 0) {
            s.sprite.material.opacity = Math.max(0, s.sprite.material.opacity - dt * 2.5);
         }
      }
      return;
   }
   // Derive camera basis
   const q = camera.quaternion;
   const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(q);
   const right = new THREE.Vector3(1,0,0).applyQuaternion(q);
   const up = new THREE.Vector3(0,1,0).applyQuaternion(q);

   const spread = 16; // half-width/height of spawn box
   const minZ = 18, maxZ = 110; // distance ahead
   const baseSpeed = 180, extra = 420; // units/sec along forward
   const targetOpacity = 0.15 + 0.45 * THREE.MathUtils.clamp(boostFx, 0, 1);
   for (const s of speedLines.sprites) {
      const sp = s.sprite;
      if (s.life <= 0 || !sp.visible) {
         // respawn ahead of camera
         const dx = (Math.random()*2-1) * spread;
         const dy = (Math.random()*2-1) * spread;
         const dz = THREE.MathUtils.lerp(minZ, maxZ, Math.random());
         const pos = camera.position.clone()
            .add(right.multiplyScalar(dx))
            .add(up.multiplyScalar(dy))
            .add(fwd.clone().multiplyScalar(dz));
         sp.position.copy(pos);
         // Randomize length and speed with boost
         const len = 2.2 + Math.random()*4.5 + boostFx*3.5;
         sp.scale.set(0.06, len, 1);
         s.vel = (baseSpeed + extra * boostFx + Math.random()*120);
         s.maxLife = THREE.MathUtils.mapLinear(dz, minZ, maxZ, 0.25, 0.9);
         s.life = s.maxLife;
         sp.visible = true;
         sp.material.opacity = 0.0;
      } else {
         // move towards camera along -fwd
         sp.position.addScaledVector(fwd, -s.vel * dt);
         s.life -= dt;
      }
      // fade in/out
      const t = 1 - (s.life / s.maxLife);
      const o = (t < 0.2) ? (t/0.2) : (t > 0.8 ? (1 - t)/0.2 : 1);
      sp.material.opacity = THREE.MathUtils.clamp(o * targetOpacity, 0, 1);
      // if behind camera, force recycle
      const toCam = sp.position.clone().sub(camera.position);
      if (toCam.dot(fwd) < -5) {
         s.life = 0; sp.visible = false; sp.material.opacity = 0;
      }
   }
}

// Create a bright Sun with lens flare and light far away in the scene
function createSun(){
   const loader = new THREE.TextureLoader();
   const tex0 = loader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
   const tex3 = loader.load('https://threejs.org/examples/textures/lensflare/lensflare3.png');
   const sunPos = new THREE.Vector3(4200, 1800, -4200);

   // Soft halo billboard with smooth radial falloff to avoid any hard edge
   const glowGeo = new THREE.PlaneGeometry(1, 1);
   const glowMat = new THREE.ShaderMaterial({
      uniforms: {
         color: { value: new THREE.Color(0xffe4b5) },
         intensity: { value: 1.0 },
         power: { value: 2.6 }
      },
      vertexShader: `
         varying vec2 vUv;
         void main(){
           vUv = uv;
           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
         }
      `,
      fragmentShader: `
         uniform vec3 color;
         uniform float intensity;
         uniform float power;
         varying vec2 vUv;
         void main(){
           vec2 p = vUv * 2.0 - 1.0; // -1..1
           float r = length(p);
           float a = pow(max(0.0, 1.0 - r), power) * intensity;
           gl_FragColor = vec4(color * a, a);
         }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: false
   });
   sunGlow = new THREE.Mesh(glowGeo, glowMat);
   sunGlow.scale.set(1400, 1400, 1);
   sunGlow.position.copy(sunPos);
   scene.add(sunGlow);

   // Smaller, softer core sprite layered on top for a bright center picked up by bloom
   const coreMat = new THREE.SpriteMaterial({ map: tex0, color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false, depthTest: false });
   sunCore = new THREE.Sprite(coreMat);
   sunCore.scale.set(320, 320, 1);
   sunCore.position.copy(sunPos);
   scene.add(sunCore);

   // Point light to act as sun illumination in that direction
   sunLight = new THREE.PointLight(0xfff4d6, 1.35, 12000, 2);
   sunLight.position.copy(sunPos);
   scene.add(sunLight);

   // Lens flare chained to the light (slightly toned down sizes)
   const flare = new THREE.Lensflare();
   flare.addElement(new THREE.LensflareElement(tex0, 600, 0, new THREE.Color(0xffeedd)));
   flare.addElement(new THREE.LensflareElement(tex3, 100, 0.4));
   flare.addElement(new THREE.LensflareElement(tex3, 60, 0.7));
   flare.addElement(new THREE.LensflareElement(tex3, 80, 1.0));
   sunLight.add(flare);
}

// Small additive sprite "nav lights" on ships to improve visibility
// (Removed) Ship nav lights were sprite-based; no longer used for saucer enemies.

function createShips(count) {
   const rng = () => Math.random();
   for (let i = 0; i < count; i++) {
   // Radius with occasional larger orbits so ships can come closer to the camera line
   const radius = (rng() < 0.35) ? (90 + rng() * 70) : (35 + rng() * 85);
   // Mild eccentricity so ships sometimes move closer/farther
   const ecc = rng() * 0.35; // 0..0.35
   const eccPhase = rng() * Math.PI * 2;
      const speed = (rng() * 0.25 + 0.05) * (rng() < 0.5 ? -1 : 1); // radians/sec
      const phase = rng() * Math.PI * 2;

      // Random orbit plane
      const normal = new THREE.Vector3(rng() * 2 - 1, rng() * 2 - 1, rng() * 2 - 1).normalize();
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);

      // Enemy ship as a dark saucer: squashed sphere with a small top light
      const saucerGeo = new THREE.SphereGeometry(1.8, 28, 20);
      // black material with slight metalness
        const saucerMat = new THREE.MeshStandardMaterial({ color: 0x111122, metalness: 0.7, roughness: 0.4 });


      const mesh = new THREE.Mesh(saucerGeo, saucerMat);
      const s = 1.2 + rng() * 0.6; // 1.2 .. 1.8 overall size
      mesh.scale.set(s, 0.2 * s, s); // flatten Y for saucer shape
      scene.add(mesh);
      // Single point light on top for a subtle beacon
      const topLight = new THREE.PointLight(0x88aaff, 0.8, 63, 2);
      topLight.position.set(0, 1.0, 0);
      mesh.add(topLight);

      // Create a glow trail for this ship
   const trailLen = 96; // longer trail
      const trailPositions = new Float32Array(trailLen * 3);
      const trailColors = new Float32Array(trailLen * 3);
      // initialize with zeros and a red->dark gradient
      for (let j = 0; j < trailLen; j++) {
        const t = 1 - j / (trailLen - 1); // head bright, tail dark
        const idx = j * 3;
        trailPositions[idx] = 0; trailPositions[idx + 1] = 0; trailPositions[idx + 2] = 0;
        // bright red fading to near black
        trailColors[idx] = 1.0 * t;
        trailColors[idx + 1] = 0.1 * t;
        trailColors[idx + 2] = 0.15 * t;
      }
      const trailGeom = new THREE.BufferGeometry();
      trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      trailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
            const trailMat = new THREE.PointsMaterial({
        map: trailTexture,
               size: 1.2, // smaller points for tighter trails
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        color: 0xffffff,
        sizeAttenuation: true
      });
   const trail = new THREE.Points(trailGeom, trailMat);
      scene.add(trail);

      ships.push({ mesh, radius, ecc, eccPhase, speed, phase, q, trail: { len: trailLen, geom: trailGeom, positions: trailPositions, colors: trailColors }, trailObj: trail, prevPos: null, planetId: null, center: earth.position.clone() });
   }
}

function updateShips(elapsed) {
   for (const s of ships) {
      const t = s.speed * elapsed + s.phase;
      // Apply eccentricity to vary distance over time
      const rNow = s.radius * (1 - 0.4 * s.ecc * Math.cos(t * 0.7 + s.eccPhase));
      const base = new THREE.Vector3(Math.cos(t) * rNow, Math.sin(t) * rNow, 0);
      base.applyQuaternion(s.q);
      const center = s.center || earth.position;
      const pos = base.add(center);
      s.mesh.position.copy(pos);

      // Face along actual velocity direction using previous position when available
      let vel = null;
      if (s.prevPos) {
        vel = pos.clone().sub(s.prevPos);
      } else {
        // fallback to analytical tangent for first frame
        vel = new THREE.Vector3(-Math.sin(t) * rNow, Math.cos(t) * rNow, 0).applyQuaternion(s.q);
      }
         if (vel.lengthSq() > 1e-6) {
            const forward = pos.clone().add(vel.normalize());
            s.mesh.lookAt(forward);
            // Apply fixed left yaw so the model's nose truly matches velocity direction
            s.mesh.quaternion.multiply(ENEMY_YAW_LEFT);
         }
      s.prevPos = pos.clone();

      // Update trail: shift positions down and write the new head position slightly behind the ship
   const tp = s.trail.positions;
      const len = s.trail.len;
      // shift: from tail to head
      for (let i = len - 1; i > 0; i--) {
        tp[i * 3] = tp[(i - 1) * 3];
        tp[i * 3 + 1] = tp[(i - 1) * 3 + 1];
        tp[i * 3 + 2] = tp[(i - 1) * 3 + 2];
      }
      let headPos = pos;
      if (vel && vel.lengthSq() > 1e-10) {
         const offset = 1.6 * (s.mesh.scale && s.mesh.scale.x ? s.mesh.scale.x : 1);
         const back = vel.clone().normalize().multiplyScalar(offset);
         headPos = pos.clone().sub(back);
      }
      tp[0] = headPos.x; tp[1] = headPos.y; tp[2] = headPos.z;
      s.trail.geom.attributes.position.needsUpdate = true;
   }
}

function animate() {
   requestAnimationFrame(animate);

   const now = clock.getElapsedTime();
   gameTime = now;
   const elapsed = now;
   const dt = Math.max(0.001, Math.min(0.05, now - (lastTime || now)));
   lastTime = now;

   // Subtle motions
   if (stars) {
      stars.rotation.y += 0.0003;
   }
   if (earth) {
      earth.rotation.y += 0.0008; // slow Earth spin
      // Subtle emissive flicker to make orange "fires" feel alive
      const base = 0.6, amp = 0.12, freq = 3.2;
      const eInt = base + amp * (0.5 + 0.5 * Math.sin(now * freq));
      if (earth.material && 'emissiveIntensity' in earth.material) {
         earth.material.emissiveIntensity = eInt;
      }
   }
   // Keep sun halo facing the camera for a perfect billboard
   if (sunGlow) {
      sunGlow.quaternion.copy(camera.quaternion);
   }
   updateShips(elapsed);

   // Process a few deferred cleanups per frame to avoid GC spikes
   if (cleanupQueue && cleanupQueue.length) {
      const n = Math.min(3, cleanupQueue.length);
      for (let i = 0; i < n; i++) {
         try { cleanupQueue.shift()?.(); } catch(_){ }
      }
   }

      if (flightMode) {
         updateFlight(dt);
         updateSpeedLines(dt);
         updateBullets(dt);
         updateExplosions(dt);
         updateEnemiesFire(dt);
         updateEnemyBullets(dt);
         checkVictory();
      } else if (cameraOrbit && earth) {
         // Slow diagonal camera orbit around Earth when not in flight mode
         cameraOrbit.theta += cameraOrbit.speed * dt;
         const base = new THREE.Vector3(
           Math.cos(cameraOrbit.theta) * cameraOrbit.radius,
           0,
           Math.sin(cameraOrbit.theta) * cameraOrbit.radius
         );
         base.applyQuaternion(cameraOrbit.tilt);
         base.y += cameraOrbit.height; // keep average height while tilted
         camera.position.copy(base);
         camera.lookAt(earth.position);
      }

      // Apply camera shake at the end so it affects the final view
      if (shakeTime > 0) {
         const t = shakeTime / shakeDuration;
         const s = shakeMagnitude * t * t; // ease-out by squaring
         const rW = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
         const uW = new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion);
         const fW = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
         camera.position
            .addScaledVector(rW, (Math.random()*2-1) * 0.06 * s)
            .addScaledVector(uW, (Math.random()*2-1) * 0.05 * s)
            .addScaledVector(fW, (Math.random()*2-1) * 0.04 * s);
         const e = new THREE.Euler((Math.random()*2-1)*0.003*s, (Math.random()*2-1)*0.003*s, 0, 'YXZ');
         camera.quaternion.multiply(new THREE.Quaternion().setFromEuler(e));
         shakeTime = Math.max(0, shakeTime - dt);
      }

      // Damage flash fade
      if (damageFlashEl) {
         // Exponential decay
         damageFlashAlpha = Math.max(0, damageFlashAlpha * Math.exp(-dt * 6));
         damageFlashEl.style.backgroundColor = `rgba(255, 40, 20, ${0.55 * damageFlashAlpha})`;
      }

      composer.render();
}
function onWindowResize() {
   camera.aspect = window.innerWidth / window.innerHeight;
   camera.updateProjectionMatrix();
   renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) {
         composer.setSize(window.innerWidth, window.innerHeight);
         if (bloomPass) bloomPass.setSize(window.innerWidth, window.innerHeight);
      }
}

// Defer init() call until after helper functions (planets, curiosa) are defined
</script>
<script>
// Distant planets and curiosa handling
function createDistantPlanets(){
   const makePlanet = (id, pos, color, radius, enemyCount)=>{
      const geom = new THREE.SphereGeometry(radius, 32, 32);
      const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.0, roughness: 1.0, emissive: 0x000000 });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(pos);
      scene.add(mesh);
      const planet = { id, mesh, radius, enemies: [], revealed: false };
      planets.push(planet);
      // spawn a few enemies orbiting this planet
      const planeQ = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(Math.random(),Math.random(),Math.random()).normalize());
      for (let i=0;i<enemyCount;i++) {
         const sh = createPlanetEnemy(planet, planeQ);
         planet.enemies.push(sh);
      }
   };
   makePlanet('p1', new THREE.Vector3(3000, 1200, -3500), 0x6699ff, 140, 3);
   makePlanet('p2', new THREE.Vector3(-4200, -1800, 2800), 0xff8844, 180, 3);
   makePlanet('p3', new THREE.Vector3(5200, -900, 4300), 0x88ff66, 160, 2);
   makePlanet('p4', new THREE.Vector3(-5800, 2100, -4800), 0xbb88ff, 200, 4);
}

function createPlanetEnemy(planet, planeQ){
   // parameters
   const radius = 260 + Math.random()*220;
   const ecc = Math.random()*0.25;
   const eccPhase = Math.random()*Math.PI*2;
   const speed = (0.04 + Math.random()*0.12) * (Math.random()<0.5 ? -1 : 1);
   const phase = Math.random()*Math.PI*2;
   // mesh: dark saucer (squashed sphere) with a top light
   const saucerGeo = new THREE.SphereGeometry(1.8, 28, 20);
   const saucerMat = new THREE.MeshStandardMaterial({ color: 0x111122, metalness: 0.7, roughness: 0.4 });
   const mesh = new THREE.Mesh(saucerGeo, saucerMat);
   const s = 1.2 + Math.random() * 0.6; // match near-Earth saucers: 1.2..1.8
   mesh.scale.set(s, 0.2 * s, s); // flatter profile like near-Earth
   scene.add(mesh);
   const topLight = new THREE.PointLight(0x88aaff, 0.8, 63, 2);
   topLight.position.set(0, 1.0, 0);
   mesh.add(topLight);
   // trail
   const trailLen = 72;
   const trailPositions = new Float32Array(trailLen * 3);
   const trailColors = new Float32Array(trailLen * 3);
   for (let j=0;j<trailLen;j++){
      const t = 1 - j/(trailLen-1);
      const idx=j*3; trailPositions[idx]=0; trailPositions[idx+1]=0; trailPositions[idx+2]=0;
      trailColors[idx]=1.0*t; trailColors[idx+1]=0.25*t; trailColors[idx+2]=0.15*t;
   }
   const trailGeom = new THREE.BufferGeometry();
   trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
   trailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
   const trailMat = new THREE.PointsMaterial({ map: trailTexture, size: 1.1, transparent: true, depthWrite:false, blending: THREE.AdditiveBlending, vertexColors:true, color:0xffffff, sizeAttenuation:true });
   const trailObj = new THREE.Points(trailGeom, trailMat);
   scene.add(trailObj);

   const ship = { mesh, radius, ecc, eccPhase, speed, phase, q: planeQ, trail: { len: trailLen, geom: trailGeom, positions: trailPositions, colors: trailColors }, trailObj, prevPos:null, planetId: planet.id, center: planet.mesh.position.clone(), ai: { cooldown: 1.2, timer: Math.random()*1.2 } };
   ships.push(ship);
   return ship;
}

const revealedPlanets = new Set();
function maybeShowCuriosa(planetId){
   if (revealedPlanets.has(planetId)) return;
   // any ships remaining for this planet?
   for (const s of ships){ if (s.planetId === planetId) return; }
   revealedPlanets.add(planetId);
   const text = curiosa[planetId] || 'Unknown';
   showCuriosaModal(text);
}

function showCuriosaModal(text){
   let el = document.getElementById('curiosaModal');
   if (!el){
      el = document.createElement('div');
      el.id = 'curiosaModal';
      el.className = 'modal-backdrop';
      el.innerHTML = `<div class="modal-card"><h2>Discovery</h2><p id="curiosaText"></p><div class="modal-actions"><button id="curiosaOk">OK</button></div></div>`;
      document.body.appendChild(el);
   }
   el.style.display='';
   const p = el.querySelector('#curiosaText'); if (p) p.textContent = text;
   const btn = el.querySelector('#curiosaOk'); if (btn) btn.onclick = ()=>{ el.style.display='none'; };
}
   // Now that helpers exist, run init
   init();
// Background YouTube audio (hidden player)
let ytPlayer = null;
let ytReady = false;
let ytPlayWhenReady = false;
let ytLoopInterval = null;

function createYouTubePlayer(){
   if (ytPlayer || !(window.YT && YT.Player)) return;
   ytPlayer = new YT.Player('yt-holder', {
      height: '1',
      width: '1',
      videoId: 'gWkT7Mb3zAE', // NeoFuture
      playerVars: {
         autoplay: 0,
         controls: 0,
         rel: 0,
         modestbranding: 1,
         playsinline: 1,
         origin: location.origin
      },
      events: {
         onReady: (e) => {
            ytReady = true;
            if (ytPlayWhenReady) {
               try { e.target.setVolume(100); e.target.playVideo(); } catch(_){}
               ytPlayWhenReady = false;
            }
            ensureYtLoop();
         }
      }
   });
}

// Damage FX helpers
function setupDamageFx(){
   damageFlashEl = document.getElementById('damageFlash');
}

function onPlayerDamaged(amount){
   // Flash intensity and shake scale with damage amount
   damageFlashAlpha = Math.min(1, damageFlashAlpha + (amount * 0.04));
   shakeTime = Math.min(shakeDuration, shakeTime + 0.10 + amount * 0.004);
   shakeMagnitude = Math.min(1.0, 0.4 + amount * 0.03);
}

window.onYouTubeIframeAPIReady = function(){
   // Ensure a player exists as soon as API is ready
   createYouTubePlayer();
};

function startBackgroundYouTube(){
   // Ensure player exists
   if (!ytPlayer) createYouTubePlayer();
   if (ytPlayer && ytReady) {
      try { ytPlayer.setVolume(100); ytPlayer.playVideo(); } catch(_){/* ignore */}
      ensureYtLoop();
   } else {
      ytPlayWhenReady = true;
   }
}

function ensureYtLoop(){
   if (ytLoopInterval) return;
   ytLoopInterval = setInterval(()=>{
      try {
         if (!ytPlayer || !ytReady || !ytPlayer.getCurrentTime) return;
         const t = ytPlayer.getCurrentTime();
         if (t >= 90) {
            ytPlayer.seekTo(0, true);
            ytPlayer.playVideo();
         }
      } catch(_){}
   }, 1000);
}

// Local audio playback for NeoFuture (requires you to place ./audio/neofuture.mp3)
(function(){
   const btn = document.getElementById('playNeo');
   if (!btn) return;
   const audio = new Audio('./audio/neofuture.mp3');
   audio.preload = 'none';
   let playing = false;
   btn.addEventListener('click', async () => {
      try {
         if (!playing) {
            await audio.play();
            playing = true;
            btn.textContent = 'Pause NeoFuture';
         } else {
            audio.pause();
            playing = false;
            btn.textContent = 'Play NeoFuture';
         }
      } catch (e) {
         // Likely file missing or autoplay blocked; guide user to Spotify
         btn.textContent = 'Use Spotify (no local file)';
      }
   });
   audio.addEventListener('ended', ()=>{
      playing = false;
      btn.textContent = 'Play NeoFuture';
   });
})();

// Hover SFX: lightweight synth "sci-fi" beep on button/icon hover
(function(){
   let ctx = null;
   let unlocked = false;
   function ensureCtx(){
      if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === 'suspended') ctx.resume();
   }
   function unlock(){
      ensureCtx();
      unlocked = true;
      window.removeEventListener('pointerdown', unlock);
   }
   window.addEventListener('pointerdown', unlock, { once: true });

   function playHoverBeep(){
      ensureCtx();
      if (!ctx || ctx.state !== 'running') return;
      const t0 = ctx.currentTime;
      const dur = 0.08; // 80ms
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(1400, t0);
      osc.frequency.exponentialRampToValueAtTime(1520, t0 + dur);
      gain.gain.setValueAtTime(0.0001, t0);
      gain.gain.exponentialRampToValueAtTime(0.12, t0 + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      osc.connect(gain).connect(ctx.destination);
      osc.start(t0);
      osc.stop(t0 + dur + 0.005);
   }

   function bindHover(selector){
      document.querySelectorAll(selector).forEach(el => {
         el.addEventListener('mouseenter', playHoverBeep);
         el.addEventListener('focus', playHoverBeep);
      });
   }
   bindHover('.corner-links a, .audio-widget button, .logo-fixed');
})();

   // SFX loader and helpers
   function setupSfx(){
      if (window.__sfxInitialized) return; // idempotent
      window.__sfxInitialized = true;
      function ensureCtx(){ if (!sfxCtx) sfxCtx = new (window.AudioContext||window.webkitAudioContext)(); return sfxCtx; }
      function reverseAudioBuffer(ctx, buf){
         try {
            const numCh = buf.numberOfChannels;
            const out = ctx.createBuffer(numCh, buf.length, buf.sampleRate);
            for (let ch=0; ch<numCh; ch++){
               const src = buf.getChannelData(ch);
               const dst = out.getChannelData(ch);
               for (let i=0, j=src.length-1; i<src.length; i++, j--){ dst[i] = src[j]; }
            }
            return out;
         } catch(_) { return null; }
      }
      async function loadBuffer(url){
         try {
            const ctx = ensureCtx();
            const resp = await fetch(url);
            const arr = await resp.arrayBuffer();
            return await ctx.decodeAudioData(arr);
         } catch (e){ return null; }
      }
      // Unlock on first user interaction
      const unlock = ()=>{ ensureCtx(); if (sfxCtx.state==='suspended') sfxCtx.resume(); window.removeEventListener('pointerdown', unlock); window.removeEventListener('keydown', unlock); window.removeEventListener('mousedown', unlock); };
      window.addEventListener('pointerdown', unlock, { once: true });
      window.addEventListener('keydown', unlock, { once: true });
      window.addEventListener('mousedown', unlock, { once: true });
      // Kick off buffer loads (local files expected to exist)
      loadBuffer('./audio/scificlick.wav').then(buf=>{ sfx.click = buf; });
      loadBuffer('./audio/laser-shot.wav').then(buf=>{ sfx.laser = buf; });
      loadBuffer('./audio/explosion.wav').then(buf=>{ sfx.explosion = buf; });
   // Optional whoosh for boost engage + reversed for release
   loadBuffer('./audio/boost.wav').then(buf=>{ sfx.boost = buf; const ctx = ensureCtx(); sfx.boostRev = buf ? reverseAudioBuffer(ctx, buf) : null; });
   }

   function playSfx(name, gain=0.9){
      if (!sfxCtx || sfxCtx.state!=='running') return;
      const buf = sfx[name];
      if (!buf) return; // not loaded yet
      const src = sfxCtx.createBufferSource();
      src.buffer = buf;
      // Randomize pitch slightly so repeated SFX don't sound identical
      src.playbackRate.value = 0.96 + Math.random() * 0.1; // ~ ±5%
      const g = sfxCtx.createGain();
      g.gain.value = gain;
      src.connect(g).connect(sfxCtx.destination);
      src.start();
   }

   // Intro modal logic: open Spotify and play click SFX
   (function(){
      const modal = document.getElementById('readyModal');
      const btn = document.getElementById('readyBtn');
      if (!modal || !btn) return;
      btn.addEventListener('click', ()=>{
         playSfx('click', 0.8);
         modal.style.display = 'none';
         // Start hidden YouTube playback (user gesture compliant)
         startBackgroundYouTube();
      });
   })();

// ===== Secret Flight Mode implementation =====
function setupSecretFlightMode(){
   if (window.__flightBound) return; // idempotent
   window.__flightBound = true;
   const title = document.querySelector('.terminal h1');
   if (!title) return;
   let taps = 0;
   let tapTimer = null;
   title.addEventListener('click', () => {
      taps++;
      if (taps >= 5) {
         taps = 0;
         enterFlightMode();
      }
      clearTimeout(tapTimer);
      tapTimer = setTimeout(() => { taps = 0; }, 1500);
   });

   // Also allow one-click activation via the logo
   const logo = document.querySelector('.logo-fixed');
   if (logo) {
      logo.addEventListener('click', () => enterFlightMode());
   }
}

function enterFlightMode(){
   if (flightMode) return;
   flightMode = true;
   score = 0;
   // Update HUD
   const hud = document.querySelector('.hud');
   if (hud) hud.textContent = `FLIGHT MODE — WASD move • Mouse aim • Click to fire • Shift boost • ESC — Score: 0 | Health: ${playerHealth}`;
   // Show healthbar
   updateHealthbar(playerHealth);
   const hb = document.getElementById('healthbar');
   if (hb) { hb.style.display = ''; hb.setAttribute('aria-hidden','false'); }

   // Try pointer lock on canvas to capture mouse for aim
   const canvas = renderer.domElement;
   function lock(){ canvas.requestPointerLock?.(); }
   canvas.addEventListener('click', lock, { once: true });

   // Spawn player's ship (parent container) and attach visual model as child
   if (!playerShip) {
      playerShip = new THREE.Object3D();
      let playerModel;
      if (shipGLTF) {
         playerModel = shipGLTF.clone(true);
         playerModel.traverse((obj)=>{ if (obj.isMesh) obj.castShadow = obj.receiveShadow = false; });
         playerModel.scale.setScalar(1.8);
      } else {
         const pGeom = new THREE.BoxGeometry(2.0, 0.8, 4.0);
         const pMat = new THREE.MeshStandardMaterial({ color: 0x3bb3ff, emissive: 0x0b3a66, emissiveIntensity: 0.8, metalness: 0.1, roughness: 0.6 });
         playerModel = new THREE.Mesh(pGeom, pMat);
      }
      playerShip.add(playerModel);
      scene.add(playerShip);
      // Initialize position a bit in front of the camera
      const fwd0 = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
      playerShip.position.copy(camera.position).add(fwd0.multiplyScalar(10));
      playerShip.quaternion.copy(camera.quaternion);

   // Create engine glow sprites (left/right) as children of the ship parent (orange)
   const glowMat = new THREE.SpriteMaterial({ map: trailTexture, color: 0xff7a1a, transparent: true, opacity: 0.85, depthWrite: false, blending: THREE.AdditiveBlending });
   const glowL = new THREE.Sprite(glowMat.clone());
   const glowR = new THREE.Sprite(glowMat.clone());
   // Position behind the ship in parent local space (forward = -Z, engines at +Z)
   glowL.position.set(-0.45, -0.12, 1.6);
   glowR.position.set( 0.45, -0.12, 1.6);
   glowL.scale.set(0.35, 0.35, 0.35);
   glowR.scale.set(0.35, 0.35, 0.35);
   playerShip.add(glowL);
   playerShip.add(glowR);
      engineGlows = [glowL, glowR];

         // Create a trailing particle line for the player's ship (orange)
      const trailLen = 70;
      const trailPositions = new Float32Array(trailLen * 3);
      const trailColors = new Float32Array(trailLen * 3);
      for (let j = 0; j < trailLen; j++) {
        const t = 1 - j / (trailLen - 1);
        const idx = j * 3;
        trailPositions[idx] = 0; trailPositions[idx+1] = 0; trailPositions[idx+2] = 0;
            // orange fade
            trailColors[idx] = 1.0 * t;      // R
            trailColors[idx+1] = 0.45 * t;   // G
            trailColors[idx+2] = 0.05 * t;   // B
      }
      const pTrailGeom = new THREE.BufferGeometry();
      pTrailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      pTrailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
         const pTrailMat = new THREE.PointsMaterial({ map: trailTexture, size: 1.6, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true, color: 0xffffff, sizeAttenuation: true });
      const pTrailPoints = new THREE.Points(pTrailGeom, pTrailMat);
      scene.add(pTrailPoints);
      playerTrail = { len: trailLen, geom: pTrailGeom, positions: trailPositions, colors: trailColors, points: pTrailPoints };
   }

   // Hide overlay text when entering flight mode
   const overlay = document.querySelector('.overlay');
   if (overlay) overlay.style.display = 'none';

   // Arm enemy ships: give them simple AI fire timers
   for (const s of ships) {
      s.ai = s.ai || {};
      s.ai.cooldown = 0.7 + Math.random() * 1.4; // seconds between shots
      s.ai.timer = Math.random() * s.ai.cooldown; // desync starts
   }

   // Key listeners
   window.addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') keys.w = true;
      if (e.code === 'KeyA') keys.a = true;
      if (e.code === 'KeyS') keys.s = true;
      if (e.code === 'KeyD') keys.d = true;
      if (e.code === 'KeyQ') keys.q = true;
      if (e.code === 'KeyE') keys.e = true;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
   });
   window.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') keys.w = false;
      if (e.code === 'KeyA') keys.a = false;
      if (e.code === 'KeyS') keys.s = false;
      if (e.code === 'KeyD') keys.d = false;
      if (e.code === 'KeyQ') keys.q = false;
      if (e.code === 'KeyE') keys.e = false;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
   });

   // Mouse look
   function onMouseMove(e){
      if (document.pointerLockElement === renderer.domElement) {
         const sens = 0.0025;
         yawTarget   -= e.movementX * sens;
         pitchTarget -= e.movementY * sens;
         pitchTarget = Math.max(-maxPitch, Math.min(maxPitch, pitchTarget));
      }
   }
   window.addEventListener('mousemove', onMouseMove);

   // Fire
   window.addEventListener('mousedown', (e) => {
      if (e.button === 0) fireBullet();
   });

   // Open Spotify search for the song in a new tab (within user gesture cascade)
      // Moved to intro modal acceptance to avoid multiple tabs
   // Initialize engine audio when flight begins
   initEngineAudio();
}

function updateHealthbar(value){
   const hb = document.getElementById('healthbar');
   if (!hb) return;
   const fill = hb.querySelector('.fill');
   const label = hb.querySelector('.label');
   const pct = Math.max(0, Math.min(100, Math.round(value)));
   if (fill) fill.style.width = pct + '%';
   if (label) label.textContent = pct.toString();
   if (pct <= 30) hb.classList.add('low'); else hb.classList.remove('low');
}

function updateFlight(dt){
   // Apply mobile look deltas (if any) to targets before smoothing
   if (mobile.active && (mobile.lookDelta.x !== 0 || mobile.lookDelta.y !== 0)) {
      const touchSens = 0.0032; // radians per pixel
      yawTarget   -= mobile.lookDelta.x * touchSens;
      pitchTarget -= mobile.lookDelta.y * touchSens;
      pitchTarget = Math.max(-maxPitch, Math.min(maxPitch, pitchTarget));
      mobile.lookDelta.x = 0; mobile.lookDelta.y = 0;
   }
   // Smooth yaw/pitch toward targets for lerpy controls
   const dampRot = 1 - Math.exp(-dt * 16);
   yaw   += (yawTarget   - yaw)   * dampRot;
   pitch += (pitchTarget - pitch) * dampRot;
   // Build orientation from yaw/pitch
   const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
   camera.quaternion.copy(q);
   // Movement vectors
   const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(q);
   const right = new THREE.Vector3(1,0,0).applyQuaternion(q);
   const up = new THREE.Vector3(0,1,0).applyQuaternion(q);
   // Gradual acceleration: accelerate velocity toward desired input direction
   const baseSpeed = 60;
   const boostSpeed = 220;
   const targetSpeed = keys.shift ? boostSpeed : baseSpeed; // units/sec
   let wish = new THREE.Vector3();
   // Desktop keys
   if (keys.w) wish.add(fwd);
   if (keys.s) wish.sub(fwd);
   if (keys.a) wish.sub(right);
   if (keys.d) wish.add(right);
   // Q/E vertical translation (up/down)
   if (keys.q) wish.sub(up);
   if (keys.e) wish.add(up);
   // Mobile joystick (overrides horizontal plan motion)
   if (mobile.active) {
      const mag = Math.hypot(mobile.move.x, mobile.move.y);
      if (mag > 0.01) {
         const mRight = right.clone().multiplyScalar(mobile.move.x);
         const mFwd   = fwd.clone().multiplyScalar(mobile.move.y);
         wish.copy(mRight.add(mFwd));
         // Scale speed by joystick magnitude 0..1
         wish.normalize().multiplyScalar(targetSpeed * Math.min(1, mag));
      }
   }
   if (wish.lengthSq() > 0 && !mobile.active) wish.normalize().multiplyScalar(targetSpeed);
   const acc = keys.shift ? 420 : 120; // stronger acceleration when boosting
   const toTarget = wish.clone().sub(playerVel);
   const maxDelta = acc * dt;
   if (toTarget.length() > maxDelta) {
      toTarget.setLength(maxDelta);
   }
   playerVel.add(toTarget);
   // Light drag to prevent infinite drift
   const drag = 0.06; // per second
   playerVel.multiplyScalar(Math.max(0, 1 - drag * dt));
   camera.position.addScaledVector(playerVel, dt);

   // Planet collisions: instant death (Earth and distant planets)
   if (earth) {
      const earthR = 20.0; // matches earth sphere
      const d = camera.position.distanceTo(earth.position);
      if (d < earthR + 0.1) {
         // Game over on impact
         setTimeout(()=>{ location.reload(); }, 100);
         return; // stop further updates this frame
      }
   }
   if (planets && planets.length) {
      for (const p of planets) {
         const r = (p && typeof p.radius === 'number') ? p.radius : 120;
         const d = camera.position.distanceTo(p.mesh.position);
         if (d < r + 1.0) { // small allowance for visual surface
            setTimeout(()=>{ location.reload(); }, 100);
            return;
         }
      }
   }

   // Update engine audio (idle vs thrust)
   // Throttle based on forward speed component relative to target speed
   const forwardSpeed = playerVel.dot(fwd);
   const forwardRatio = THREE.MathUtils.clamp(Math.abs(forwardSpeed) / Math.max(1, targetSpeed), 0, 1);
   const hasKeyInput = keys.w || keys.s || keys.a || keys.d || keys.q || keys.e;
   const mobileMag = Math.hypot(mobile.move.x, mobile.move.y);
   const hasMobileInput = mobile.active && mobileMag > 0.05;
   engineThrottleTarget = (hasKeyInput || hasMobileInput) ? forwardRatio : 0.0;
   updateEngineAudio(dt);

   // Compute boost FX target (0..1) only when clearly boosting forward
   const wasBoost = wasBoosting;
   const isBoosting = keys.shift && forwardRatio > 0.5;
   // Play a short whoosh when boost engages (edge-triggered)
   if (isBoosting && !wasBoost) {
      // Debounce in case of rapid toggling
      if (!lastBoostSfxTime || (gameTime - lastBoostSfxTime) > 0.25) {
         playSfx('boost', 0.7);
         lastBoostSfxTime = gameTime;
      }
   }
   // Play reversed whoosh on boost release (falling edge)
   if (!isBoosting && wasBoost) {
      if (!lastBoostReleaseSfxTime || (gameTime - lastBoostReleaseSfxTime) > 0.25) {
         playSfx('boostRev', 0.6);
         lastBoostReleaseSfxTime = gameTime;
      }
   }
   const boostTarget = isBoosting ? THREE.MathUtils.clamp((forwardRatio - 0.5) / 0.5, 0, 1) : 0;
   const boostSmooth = 1 - Math.exp(-dt * 6);
   boostFx += (boostTarget - boostFx) * boostSmooth;
   // Keep Afterimage disabled entirely (we'll use vignette + FOV instead)
   if (afterimagePass) afterimagePass.enabled = false;
   // Apply boost FX to vignette and camera FOV
   if (vignettePass) vignettePass.uniforms.amount.value = boostFx * 0.5; // very subtle
   const baseFov = 60, maxKick = 6; // degrees
   const newFov = baseFov + boostFx * maxKick;
   if (Math.abs(camera.fov - newFov) > 0.01) { camera.fov = newFov; camera.updateProjectionMatrix(); }
   // Update boost state memory
   wasBoosting = isBoosting;

   // Boost-only motion blur: enable subtle Afterimage only when boosting

   // Keep player's ship attached to camera orientation/position
   if (playerShip) {
   // Smooth target-based sway and bank (prefer mobile stick if active)
   const lr = mobile.active ? mobile.move.x : ( (keys.d ? 1 : 0) - (keys.a ? 1 : 0) );
   const fb = mobile.active ? mobile.move.y : ( (keys.w ? 1 : 0) - (keys.s ? 1 : 0) );
   const ud = (keys.e ? 1 : 0) - (keys.q ? 1 : 0);
      shipSwayTarget = lr * 1.2; // meters
      shipBankTarget = lr * THREE.MathUtils.degToRad(18); // roll degrees
   shipPitchLeanTarget = (fb + 0.6 * ud) * THREE.MathUtils.degToRad(6); // slight nose tilt plus up/down
      const damp = 1 - Math.exp(-dt * 10); // smoothing factor ~ critically damped
      shipSway += (shipSwayTarget - shipSway) * damp;
      shipBank += (shipBankTarget - shipBank) * damp;
      shipPitchLean += (shipPitchLeanTarget - shipPitchLean) * damp;

   // Compose ship orientation: camera orientation + roll (around forward) + slight pitch lean (around right)
   const qRoll = new THREE.Quaternion().setFromAxisAngle(fwd, shipBank);
   const qPitchLean = new THREE.Quaternion().setFromAxisAngle(right, -shipPitchLean);
   const shipQuat = q.clone().multiply(qRoll).multiply(qPitchLean);
   playerShip.quaternion.copy(shipQuat).multiply(PLAYER_YAW_LEFT);

         const shipOffset = 10.0; // meters in front of camera
         const downOffset = 1.2;  // place ship slightly below camera center
         playerShip.position.copy(camera.position)
            .add(fwd.clone().multiplyScalar(shipOffset))
            .add(right.clone().multiplyScalar(shipSway))
            .add(up.clone().multiplyScalar(-downOffset));

      // Update engine glows placement, flicker and scale based on thrust
      const thrust = (keys.w ? 1.0 : 0.35) + (keys.shift ? 0.4 : 0);
      // Engine glows have fixed local offsets on the ship; no per-frame repositioning needed
      for (const s of engineGlows) {
         const flicker = 0.7 + Math.random() * 0.6;
         const k = 1.0 + thrust * 0.6;
         s.scale.set(0.35 * k * flicker, 0.35 * k * flicker, 1);
         s.material.opacity = 0.5 + 0.25 * Math.random();
      }
   }

   // Update player's trail
   if (playerTrail && playerShip) {
      const tp = playerTrail.positions;
      const len = playerTrail.len;
      for (let i = len - 1; i > 0; i--) {
        tp[i*3] = tp[(i-1)*3];
        tp[i*3+1] = tp[(i-1)*3+1];
        tp[i*3+2] = tp[(i-1)*3+2];
      }
   // head position a bit behind the ship to visualize exhaust
   const back = new THREE.Vector3(0,0,1).applyQuaternion(playerShip.quaternion);
   const head = playerShip.position.clone().add(back.multiplyScalar(3.0));
      tp[0] = head.x; tp[1] = head.y; tp[2] = head.z;
      playerTrail.geom.attributes.position.needsUpdate = true;
   }
   // Auto-fire while holding mobile fire button
   if (mobile.active && mobile.firing) {
      fireBullet();
   }
}

function initEngineAudio(){
   try {
      if (!sfxCtx) sfxCtx = new (window.AudioContext||window.webkitAudioContext)();
      if (engine.initialized || !sfxCtx) return;
      const ctx = sfxCtx;
      const master = ctx.createGain();
      master.gain.value = 0.0;
      master.connect(ctx.destination);
      // Base hum
      const baseOsc = ctx.createOscillator();
      baseOsc.type = 'sawtooth';
      baseOsc.frequency.value = 80;
      const baseGain = ctx.createGain();
      baseGain.gain.value = 0.02;
      baseOsc.connect(baseGain).connect(master);
      baseOsc.start();
      // Overtone / whine
      const overtoneOsc = ctx.createOscillator();
      overtoneOsc.type = 'triangle';
      overtoneOsc.frequency.value = 240;
      const overtoneGain = ctx.createGain();
      overtoneGain.gain.value = 0.0;
      overtoneOsc.connect(overtoneGain).connect(master);
      overtoneOsc.start();
      engine = { initialized:true, master, baseOsc, baseGain, overtoneOsc, overtoneGain };
      // Ensure context is resumed on user gesture
      const unlock = ()=>{ ctx.resume?.(); window.removeEventListener('pointerdown', unlock); };
      window.addEventListener('pointerdown', unlock, { once: true });
   } catch(_){}
}

function updateEngineAudio(dt){
   if (!engine.initialized) return;
   const smooth = 1 - Math.exp(-dt * 8);
   engineThrottle += (engineThrottleTarget - engineThrottle) * smooth;
   // Frequencies ramp with throttle
   const baseF = 80 + engineThrottle * 120;     // 80..200 Hz
   const overF = 240 + engineThrottle * 360;    // 240..600 Hz
   // Gains ramp; keep an audible idle
   const baseG = 0.02 + engineThrottle * 0.10;  // 0.02..0.12
   const overG = 0.00 + engineThrottle * 0.08;  // 0..0.08
   const masterG = 0.10 + engineThrottle * 0.12;// 0.10..0.22
   engine.baseOsc.frequency.setTargetAtTime(baseF, sfxCtx.currentTime, 0.03);
   engine.overtoneOsc.frequency.setTargetAtTime(overF, sfxCtx.currentTime, 0.03);
   engine.baseGain.gain.setTargetAtTime(baseG, sfxCtx.currentTime, 0.05);
   engine.overtoneGain.gain.setTargetAtTime(overG, sfxCtx.currentTime, 0.05);
   engine.master.gain.setTargetAtTime(masterG, sfxCtx.currentTime, 0.05);
}

function enemyShootFrom(ship){
   if (!ship || !ship.mesh) return;
   // Aim at camera position
   const origin = ship.mesh.position.clone();
   const target = camera.position.clone();
   const dir = target.clone().sub(origin).normalize();
   const mesh = new THREE.Mesh(enemyBulletGeom, enemyBulletMat.clone());
   mesh.position.copy(origin.clone().add(dir.clone().multiplyScalar(2.5))); // start a bit away from ship
   scene.add(mesh);
   enemyBullets.push({ mesh, vel: dir.multiplyScalar(120), life: 6.0, maxLife: 6.0 });
}

function updateEnemiesFire(dt){
   for (const s of ships) {
      if (!s.ai) continue;
      s.ai.timer -= dt;
      if (s.ai.timer <= 0) {
         enemyShootFrom(s);
         // next cooldown with slight randomness
         s.ai.cooldown = Math.max(0.4, (s.ai.cooldown * 0.5 + (0.7 + Math.random() * 1.2) * 0.5));
         s.ai.timer = s.ai.cooldown;
      }
   }
}

function updateEnemyBullets(dt){
   const hitR = 2.4; // hit radius around the player (camera)
   for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      b.mesh.position.addScaledVector(b.vel, dt);
      b.life -= dt;
      // Fade slightly over life
      const t = Math.max(0, b.life / b.maxLife);
      b.mesh.material.opacity = 0.2 + 0.8 * t;
      // Hit test vs player
      const playerPos = camera.position; // treat camera as player center
      if (b.mesh.position.distanceTo(playerPos) < hitR) {
         // Damage player
         playerHealth = Math.max(0, playerHealth - 15);
         onPlayerDamaged(15);
         updateHealthbar(playerHealth);
         const hud = document.querySelector('.hud');
         if (hud) hud.textContent = `FLIGHT MODE — WASD move • Mouse aim • Click to fire • Shift boost • ESC — Score: ${score} | Health: ${playerHealth}`;
         // small explosion for hit
         spawnExplosion(b.mesh.position.clone());
         scene.remove(b.mesh);
         enemyBullets.splice(i, 1);
         if (playerHealth <= 0) {
            // Game over: reload the site
            setTimeout(()=>{ location.reload(); }, 200);
            return;
         }
         continue;
      }
      if (b.life <= 0) {
         scene.remove(b.mesh);
         enemyBullets.splice(i, 1);
      }
   }
}

function checkVictory(){
   if (!flightMode || victoryShown) return;
   if (ships.length === 0) {
      victoryShown = true;
      const modal = document.getElementById('winModal');
      if (modal) {
         modal.style.display = '';
         const btn = document.getElementById('winOkBtn');
         btn && btn.addEventListener('click', ()=>{ modal.style.display = 'none'; });
      }
   }
}

function fireBullet(){
   if (!flightMode) return;
   if (fireCooldown > 0) return;
   fireCooldown = 0.09; // ~11 rps
   playSfx('laser', 0.7);
   const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
   const muzzleOffset = 3.0;
   const start = (playerShip ? playerShip.position.clone() : camera.position.clone()).add(dir.clone().multiplyScalar(muzzleOffset));
   const mesh = new THREE.Mesh(bulletGeom, bulletMat.clone());
   mesh.position.copy(start);
   scene.add(mesh);
   bullets.push({ mesh, vel: dir.multiplyScalar(240), life: 2.2, maxLife: 2.2 });
}

function updateBullets(dt){
   fireCooldown = Math.max(0, fireCooldown - dt);
   for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.mesh.position.addScaledVector(b.vel, dt);
      b.life -= dt;
      const t = Math.max(0, b.life / b.maxLife);
      b.mesh.material.opacity = 0.2 + 0.8 * t;
      // Collision with ships
      for (let j = ships.length - 1; j >= 0; j--) {
         const s = ships[j];
         const dist = b.mesh.position.distanceTo(s.mesh.position);
         const hitR = 3.0; // generous hit radius
         if (dist < hitR) {
            // Destroy ship and defer heavy cleanup to smooth frame time
            const shipMesh = s.mesh;
            const shipTrail = s.trailObj;
            scene.remove(shipMesh);
            if (shipTrail) scene.remove(shipTrail);
            cleanupQueue.push(()=>{
               try { shipMesh.geometry?.dispose?.(); } catch(_){}
               try {
                  if (Array.isArray(shipMesh.material)) shipMesh.material.forEach(m=>m?.dispose?.());
                  else shipMesh.material?.dispose?.();
               } catch(_){}
               if (shipTrail) {
                  try { shipTrail.geometry?.dispose?.(); } catch(_){}
                  try { shipTrail.material?.dispose?.(); } catch(_){}
               }
            });
            const defeatedPlanet = s.planetId;
            ships.splice(j, 1);
            spawnExplosion(s.mesh.position.clone());
            score += 1;
            const hud = document.querySelector('.hud');
            if (hud) hud.textContent = `FLIGHT MODE — WASD move • Mouse aim • Click to fire • Shift boost • ESC to release — Score: ${score}`;
            // If this ship belonged to a planet and all of that planet's enemies are gone, show curiosa
            if (defeatedPlanet) maybeShowCuriosa(defeatedPlanet);
            // Remove bullet on hit
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            break;
         }
      }
      if (b.life <= 0) {
         scene.remove(b.mesh);
         bullets.splice(i, 1);
      }
   }
}

function spawnExplosion(pos){
   const count = 24;
   const positions = new Float32Array(count * 3);
   const colors = new Float32Array(count * 3);
   const velocities = [];
   for (let i = 0; i < count; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const dir = new THREE.Vector3(
         Math.sin(phi) * Math.cos(theta),
         Math.sin(phi) * Math.sin(theta),
         Math.cos(phi)
      );
      positions[i*3] = pos.x;
      positions[i*3+1] = pos.y;
      positions[i*3+2] = pos.z;
      const c = i % 2 === 0 ? new THREE.Color(0xff4422) : new THREE.Color(0xffff88);
      colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
      velocities.push(dir.multiplyScalar(40 + Math.random()*80));
   }
   const geom = new THREE.BufferGeometry();
   geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
   geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
   const mat = new THREE.PointsMaterial({ map: trailTexture, size: 10, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true, color: 0xffffff });
   const points = new THREE.Points(geom, mat);
   scene.add(points);
   explosions.push({ points, velocities, life: 0.6, maxLife: 0.6 });
   // Play explosion SFX if available
   playSfx('explosion', 0.75);
}

function updateExplosions(dt){
   for (let i = explosions.length - 1; i >= 0; i--) {
      const ex = explosions[i];
      const posAttr = ex.points.geometry.getAttribute('position');
      for (let j = 0; j < ex.velocities.length; j++) {
         posAttr.array[j*3]   += ex.velocities[j].x * dt;
         posAttr.array[j*3+1] += ex.velocities[j].y * dt;
         posAttr.array[j*3+2] += ex.velocities[j].z * dt;
      }
      posAttr.needsUpdate = true;
      ex.life -= dt;
      const t = Math.max(0, ex.life / ex.maxLife);
      ex.points.material.size = 6 + 18 * (1 - t);
      ex.points.material.opacity = 0.15 + 0.85 * t;
      if (ex.life <= 0) {
         scene.remove(ex.points);
         explosions.splice(i, 1);
      }
   }
}
</script>
<script>
// Ensure secret flight mode listeners are bound after definitions
(function(){
  if (typeof setupSecretFlightMode === 'function') setupSecretFlightMode();
})();
// Ensure SFX system is initialized after function definitions load
(function(){
   if (typeof setupSfx === 'function') setupSfx();
})();
</script>
<!-- Hidden YouTube player container -->
<div id="yt-holder" aria-hidden="true"></div>
</body>
</html>
